<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>反射机制</title>
    <link href="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结Java中的反射机制</p>          </div><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><strong>作用：</strong><ul><li>通过Java语言中的反射机制，可以<strong>操作字节码文件</strong></li></ul></li><li><strong>应用：</strong><ul><li>编写能够<strong>动态</strong>操纵Java代码的程序</li><li>使用反射，Java可以支持用户界面生成器、对象关系映射器以及很多其他<u>需要动态查询类能力的开发工具</u>。主要作用在<strong>开发工具</strong>时</li></ul></li><li>在 <code>java.lang,reflect,*;</code> 包下</li><li>反射机制相关的重要的类：<ul><li><code>java.lang.Class</code>：整个字节码，代表一个类型（<em>整个类</em>）</li><li><code>java.lang.reflect.Method</code>：字节码中的方法字节码（类中的<em>方法</em>）</li><li><code>java.lang.reflect.Constructor</code>：字节码中的构造方法字节码（类中的<em>构造方法</em>）</li><li><code>java.lang.reflect.Field</code>：字节码中的属性字节码（类中的<em>成员变量（静态变量+实例变量）</em>）<br>  具体如下：</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chen.reflection;    <span class="hljs-comment">/**  </span><span class="hljs-comment"> * java.lang.Class</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> chen  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2025/4/5 19:18  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0  </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;      <span class="hljs-comment">// Field: 成员变量  </span>    <span class="hljs-type">int</span> no;        <span class="hljs-comment">// Constructor: 构造方法  </span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;&#125;      <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;        <span class="hljs-comment">// Method: 方法  </span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;          <span class="hljs-keyword">return</span> no;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;  &#125;</code></pre></div><p>要操作一个类的字节码，要先获取该类的字节码，即该类的 <code>Class</code>。也就是说，要操作 <code>Method</code>、<code>Constructor</code>、<code>Field</code>，需要先获取到 <code>Class</code></p><h1 id="获取Class的三种方式"><a href="#获取Class的三种方式" class="headerlink" title="获取Class的三种方式"></a>获取Class的三种方式</h1><h2 id="1、Class-forName-完整类名"><a href="#1、Class-forName-完整类名" class="headerlink" title="1、Class.forName(&quot;完整类名&quot;);"></a>1、<code>Class.forName(&quot;完整类名&quot;);</code></h2><p>要求：</p><ol><li>静态方法</li><li>方法的参数是一个字符串</li><li>字符串需要的是一个完整类名</li><li>完整类名必须带有包名</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">// c1 代表 String.class 文件，或者说代表 String 类  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);              <span class="hljs-comment">// c2代表 Date 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.util.Date&quot;</span>);              <span class="hljs-comment">// c3 代表 Integer 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Integer&quot;</span>);              <span class="hljs-comment">// c4 代表 System 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.System&quot;</span>);          &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;</code></pre></div><ul><li><code>Class.forName(&quot;完整类名&quot;);</code> - 该方法的执行，会导致<strong>类加载</strong>，类加载时，静态代码块执行：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          Class.forName(<span class="hljs-string">&quot;com.chen.reflection.MyClass&quot;</span>);      &#125;  &#125;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;      <span class="hljs-keyword">static</span> &#123;          System.out.println(<span class="hljs-string">&quot;MyClass 的静态代码块&quot;</span>);      &#125;  &#125;</code></pre></div><ul><li>输出：<br><img src="/2020250406155411.png"></li></ul><h2 id="2、对象-getClass"><a href="#2、对象-getClass" class="headerlink" title="2、对象.getClass();"></a>2、<code>对象.getClass();</code></h2><p>Java中任何一个对象都有 <code>getClass()</code> 方法：（Object类中实现的方法）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;          <span class="hljs-keyword">try</span> &#123;              c1 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);          &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;              e.printStackTrace();          &#125;            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;          <span class="hljs-comment">// x 代表 String.class 字节码文件，或者说 代表 String 类型  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.getClass();          <span class="hljs-comment">// c1 和 x 中保存的内存地址是一样的</span>        System.out.println(c1 == x);   <span class="hljs-comment">// true</span>    &#125;  &#125;</code></pre></div><p>底层实现如下：<br><img src="/2020250405193852.png"></p><h2 id="3、任何类型-class"><a href="#3、任何类型-class" class="headerlink" title="3、任何类型.class;"></a>3、<code>任何类型.class;</code></h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> String.class;          System.out.println(c);    <span class="hljs-comment">// class java.lang.String  </span>    &#125;  &#125;</code></pre></div><h1 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h1><p><strong>反射机制的灵活性：</strong></p><ul><li>Java代码在不改变源代码的基础上，可以做到不同对象的实例化</li><li>符合开闭原则：对扩展开放，对修改关闭</li></ul><p>如果我们有一个 <code>properties</code> 文件：</p><div class="code-wrapper"><pre><code class="hljs text">className=java.util.Date</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-comment">// 这种方式，只能创建一个User对象，代码写死了  </span>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();            <span class="hljs-comment">/*  </span><span class="hljs-comment">        * 以下方式，创建的对象依赖我们的properties配置文件  </span><span class="hljs-comment">        * */</span>        <span class="hljs-comment">// 通过 IO 流读取 classinfo.properties 文件  </span>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;classinfo.properties&quot;</span>);          <span class="hljs-comment">// 创建属性类对象map  </span>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();          <span class="hljs-comment">// 加载  </span>        pro.load(reader);          <span class="hljs-comment">// 关闭流  </span>        reader.close();            <span class="hljs-comment">// 通过key获取value  </span>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> pro.getProperty(<span class="hljs-string">&quot;className&quot;</span>);          System.out.println(className);            <span class="hljs-comment">// 通过反射机制实例化对象  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(className);          <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> c.newInstance();          System.out.println(o);      &#125;  &#125;</code></pre></div><h1 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-comment">// 获取整个类  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">userClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.entity.User&quot;</span>);          <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> userClass.newInstance();   <span class="hljs-comment">// obj就是User对象，底层调用该对象的无参构造方法  </span>          <span class="hljs-comment">// 获取no属性  </span>        Field noField=  userClass.getDeclaredField(<span class="hljs-string">&quot;no&quot;</span>);            <span class="hljs-comment">// 给obj对象的no属性赋值  </span>        noField.set(obj, <span class="hljs-number">111</span>);          <span class="hljs-comment">// 读取值  </span>        System.out.println(noField.get(obj));   <span class="hljs-comment">// 111  </span>    &#125;  &#125;</code></pre></div><ul><li>反射机制的<strong>缺点</strong>：<strong>打破封装，可以访问到private方法</strong></li></ul><h1 id="调用对象方法"><a href="#调用对象方法" class="headerlink" title="调用对象方法"></a><strong>调用对象方法</strong></h1><p>有个 <code>UserService</code> 类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chen.reflection.service;    <span class="hljs-comment">/**  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> chen  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2025/4/7 19:50  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0  </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String name, String password)</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="hljs-string">&quot;123&quot;</span>.equals(password)) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span> &#123;          System.out.println(<span class="hljs-string">&quot;已退出&quot;</span>);      &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">userServiceClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.service.UserService&quot;</span>);          <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> userServiceClass.newInstance();          <span class="hljs-type">Method</span> <span class="hljs-variable">loginMethod</span> <span class="hljs-operator">=</span> userServiceClass.getDeclaredMethod(<span class="hljs-string">&quot;login&quot;</span>, String.class, String.class);          <span class="hljs-comment">// 返回值  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> loginMethod.invoke(obj, <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);          System.out.println(returnValue);      &#125;  &#125;</code></pre></div><h1 id="调用构造方法实例化对象"><a href="#调用构造方法实例化对象" class="headerlink" title="调用构造方法实例化对象"></a>调用构造方法实例化对象</h1><p>现在有一个 <code>User</code> 类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;      <span class="hljs-comment">// Field  </span>    <span class="hljs-type">int</span> no;      String name;      <span class="hljs-type">int</span> age;      <span class="hljs-type">boolean</span> sex;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, <span class="hljs-type">int</span> age)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;          <span class="hljs-built_in">this</span>.age = age;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, <span class="hljs-type">int</span> age, <span class="hljs-type">boolean</span> sex)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;          <span class="hljs-built_in">this</span>.age = age;          <span class="hljs-built_in">this</span>.sex = sex;      &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.entity.User&quot;</span>);          <span class="hljs-comment">// 调用无参构造方法  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> c.newInstance();          System.out.println(obj);            <span class="hljs-comment">// 调用有参构造方法  </span>        <span class="hljs-comment">// 1、获取到这个有参数的构造方法  </span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(<span class="hljs-type">int</span>.class, String.class);          <span class="hljs-comment">// 2、调用构造方法new对象  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">newObj</span> <span class="hljs-operator">=</span> con.newInstance(<span class="hljs-number">110</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);          System.out.println(newObj);            <span class="hljs-comment">// 获取无参构造方法  </span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con2</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();          <span class="hljs-type">Object</span> <span class="hljs-variable">newObj2</span> <span class="hljs-operator">=</span> con2.newInstance();          System.out.println(newObj2);      &#125;  &#125;</code></pre></div><h1 id="获取父类和父接口"><a href="#获取父类和父接口" class="headerlink" title="获取父类和父接口"></a>获取父类和父接口</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">stringClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);            <span class="hljs-comment">// 获取String的父类  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> stringClass.getSuperclass();          System.out.println(superClass.getName());            System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);            <span class="hljs-comment">// 获取String类实现的所有接口  </span>        Class[] interfaces = stringClass.getInterfaces();          <span class="hljs-keyword">for</span> (Class in : interfaces) &#123;              System.out.println(in.getName());          &#125;      &#125;  &#125;</code></pre></div><p><img src="/2020250408200508.png"></p><h1 id="反射的弊端"><a href="#反射的弊端" class="headerlink" title="反射的弊端"></a>反射的弊端</h1><ol><li>反射很慢<ul><li>慢的原因：反射调用需要找到目标方法，而找目标方法是通过遍历当前类甚至是父类的方法来找，并且调用，这个时间复杂度<code>O(n)</code></li><li>如何解决：可以将目标方法缓存起来，下次直接调用而并非先找到目标方法再调用</li></ul></li><li>使用反射会有安全性的问题<ul><li>反射打破了封装，可以访问到private方法，可能有让黑客有窃取信息的漏洞</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL日志</title>
    <link href="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/"/>
    <url>/2025/04/07/MySQL%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结MySQL中的三大日志（redo log、undo log、binlog）</p>          </div><h1 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a>一、分类</h1><ol><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>归档日志（bin log）</li><li>错误日志（error log）</li><li>慢查询日志（slow query log）</li><li>一般查询日志（general log）</li><li>中继日志（relay log）</li></ol><h1 id="二、redo-log"><a href="#二、redo-log" class="headerlink" title="二、redo log"></a>二、redo log</h1><p>重做日志，<strong>InnoDB存储引擎独有</strong>的日志，主要作用：让MySQL拥有<strong>崩溃恢复</strong>的能力</p><ul><li>MySQL实例挂了或宕机了，重启后，InnoDB存储引擎会使用redo log恢复数据</li></ul><h2 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h2><ol><li>物理日志<ul><li>记录的是<strong>在某个数据页做了什么修改</strong></li></ul></li><li>保证数据的持久性<ul><li>redo log会在<strong>事务提交时</strong>将日志存储到磁盘 <code>Redo Log File</code> ，保证<strong>日志的持久性</strong></li><li>同时MySQL会将数据写入磁盘，保证<strong>数据的持久性</strong></li></ul></li></ol><h2 id="2、组成"><a href="#2、组成" class="headerlink" title="2、组成"></a>2、组成</h2><ol><li><p>Redo Log Buffer：内存中的重做日志<strong>缓存</strong></p></li><li><p>Redo Log File：重做日志<strong>文件</strong></p></li></ol><p>MySQL中数据是以<strong>页</strong>为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到Buffer Pool中。后续的查询都是先从Buffer Pool中找，没有命中再去硬盘加载，<strong>减少硬盘IO开销，提升性能。</strong></p><p>更新表数据的时候，也是如此，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新。然后会把在某个数据页上做了什么修改记录到重做日志缓存（Redo Log Buffer）里，接着刷盘到Redo Log文件里。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面。</p><ul><li>流程如下：</li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407162420090.png"></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><strong>固定大小</strong>，循环写入</p><ul><li>配置为一组4个文件，每个文件1GB大小</li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164547681.png"></p><ul><li><strong>注意这里有一个<code>check point</code>，如果发生异常，redolog就是根据checkpoint来感知到，数据要恢复到哪里的</strong></li></ul><h3 id="WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘"><a href="#WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘" class="headerlink" title="WAL(Write-Ahead Logging)技术：先写日志、再写磁盘"></a>WAL(Write-Ahead Logging)技术：先写日志、再写磁盘</h3><div class="note note-danger">            <p>为什么要在写磁盘前先写日志？直接写磁盘不可以吗？</p>          </div><ul><li><p>性能问题：</p><ol><li><strong>redolog结构简单：</strong><ul><li>InnoDB在磁盘中存储的基本单元是页，可能本次修改只变更一页中几个字节，但是需要刷新整页的数据，<strong>浪费资源</strong></li><li>redolog记录的是物理层面上的数据修改，因此redolog也叫物理日志。这些修改记录包含了数据页的物理地址（Page Number）和修改的具体内容（在某个数据页做了什么修改）</li><li>正是因为redolog中记录的数据结构简单，只记录一些物理地址以及变更状态等信息，因此数据先写入redolog要比直接写入到表快多了</li><li>Redo Log作为“临时存储的数据区域”，当Redo Buffer中的数据已经到达一定大小后，Redo Buffer也会将这部分数据写入到Redo Log中，此时数据还未提交，但是已经写入到磁盘中了。</li></ul></li></ol><p>  <img src="/2025/04/07/Redis-Zset/ge-20250408183748948.png" alt="InnoDB数据页和RedoLog日志格式"></p><ol start="2"><li><strong>顺序IO性能远高于随机IO：</strong><ul><li>数据在MySQL中存储是以页为单位的，一个事务可能修改了多页中的数据，页之间又是不连续的，如果直接写入到磁盘中对应的页中，就会产生<strong>随机IO，性能更差</strong></li><li>redolog是通过往redolog日志中追加数据的方式，属于<strong>顺序IO</strong>，效率高。这样可能会影响Redo Log恢复数据时的性能，但可以保证在提交时期能够快速写入Redo Log日志记录本次事务的更改。</li></ul></li></ol></li></ul><h2 id="3、刷盘时机"><a href="#3、刷盘时机" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>InnoDB存储引擎为Redo Log的刷盘策略提供了 <code>innodb-f1ush_log-at_-trX-commit</code> 参数，它支持三种策略：</p><h3 id="（1）0-延时写"><a href="#（1）0-延时写" class="headerlink" title="（1）0 延时写"></a>（1）0 延时写</h3><p>每次事务提交时都只是把redo log留在redo log buffer中，开启一个后台线程，<strong>每1s刷新一次到磁盘中</strong>：</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407163806765.png"></p><ul><li>风险：如果数据库宕机了，可能会丢失1秒内的数据</li></ul><h3 id="（2）1-实时写、实时刷"><a href="#（2）1-实时写、实时刷" class="headerlink" title="（2）1 实时写、实时刷"></a>（2）1 实时写、实时刷</h3><p>每次<strong>事务提交时</strong>都将redo log直接持久化到磁盘，<strong>真正保证数据的持久性</strong>（<strong>默认值</strong>)</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164032208.png"></p><ul><li>只要事务提交成功，redo log记录就一定在硬盘里，<strong>不会有任何数据丢失</strong></li><li>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</li></ul><h3 id="（3）2-实时写、延时刷"><a href="#（3）2-实时写、延时刷" class="headerlink" title="（3）2 实时写、延时刷"></a>（3）2 实时写、延时刷</h3><p>每次事务提交时都只是把 redo log 写到 page cache，每秒刷一次到磁盘（速度快，但是会丢1s的数据，甚至更多，1s并不严格）</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164428343.png"></p><h1 id="三、undo-log"><a href="#三、undo-log" class="headerlink" title="三、undo log"></a>三、undo log</h1><p><strong>回滚日志</strong>，redo log一旦提交意味着持久化了，但有时候需要对其进行回滚操作，那就需要undo log</p><h2 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h2><ul><li>逻辑日志，可以理解为存储的是sql：<ul><li>在事务中使用的每一条 INSERT 都对应了一条 DELETE</li><li>每一条 UPDATE 都对应一条相反的 UPDATE 语句</li></ul></li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407165157198.png"></p><ul><li>保证事务的<strong>一致性</strong></li></ul><p>详见：MVCC机制</p><h1 id="四、binlog"><a href="#四、binlog" class="headerlink" title="四、binlog"></a>四、binlog</h1><p>归档日志，MySQL的<strong>Server层</strong>实现的日志，所有引擎都可以使用，主要作用：备份恢复、灾难恢复、主从复制</p><h2 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h2><ul><li>逻辑日志，记录语句的原始逻辑</li><li><strong>追加</strong>写入，写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</li></ul><div class="note note-danger">            <p>既然有了redolog，为什么还要有binlog？</p>          </div><p>给出两个日志的对比：</p><table><thead><tr><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>InnoDB 引擎特有的</td><td>MySQL的<strong>Server层</strong>实现的，<br /><strong>所有引擎</strong>都可以使用</td></tr><tr><td><strong>物理</strong>日志，<br />记录“在某个数据页上做了什么修改”</td><td><strong>逻辑</strong>日志，<br />记录这个语句的原始逻辑（“给ID&#x3D;2这一行的c字段加1”）</td></tr><tr><td><strong>循环</strong>写，空间固定会用完</td><td><strong>追加</strong>写入，<br />写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</td></tr></tbody></table><ol><li><p><strong>历史原因：</strong></p><ul><li><p>最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="保证即使数据库发生异常重启，之前提交的记录都不会丢失的能力，我们称为**crash-safe**">[1]</span></a></sup> 的能力，binlog 日志只能用于<strong>归档</strong></p></li><li><p>InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力</p></li></ul></li><li><p><strong>用途方面：</strong></p><ul><li>正是因为binlog日志<strong>不会覆盖以前的日志</strong>的特点，如果不小心把<strong>整个数据库的数据</strong>删除了，只能使用binlog文件进行恢复，因为redolog日志的空间是固定的，会覆盖掉之前的日志。<ul><li>即：<strong>binlog用于灾难恢复的场景，而redolog只能恢复较近的数据。</strong></li></ul></li></ul></li></ol><h2 id="2、组成-1"><a href="#2、组成-1" class="headerlink" title="2、组成"></a>2、组成</h2><p>binlog有三种格式</p><h3 id="（1）Statement"><a href="#（1）Statement" class="headerlink" title="（1）Statement"></a>（1）Statement</h3><ul><li>记录<strong>SQL语句的原文</strong></li></ul><p>会出现的问题：对于一些时间函数（比如<code>now()</code>）会导致主从同步的数据前后不一致</p><h3 id="（2）Row"><a href="#（2）Row" class="headerlink" title="（2）Row"></a>（2）Row</h3><ul><li>记录<strong>数据的具体变化</strong><ul><li>insert：新插入的行的所有字段列的值</li><li>update：行更新前后的所有字段列的值</li><li>delete：行删除前的所有字段列的值</li></ul></li></ul><p>数据更安全，但同时，文件也更大</p><h3 id="（3）Mixed"><a href="#（3）Mixed" class="headerlink" title="（3）Mixed"></a>（3）Mixed</h3><p>由MySQL自主选择以上的两种格式</p><p>默认使用Statement，遇到可能导致主从不一致的SQL语句时，改用Row</p><h2 id="3、刷盘时机-1"><a href="#3、刷盘时机-1" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>和redolog一样，都是WAL日志，刷盘时机由 <code>sync_binlog</code> 配置参数指定</p><ul><li><p>0（延迟写）：每次提交事务都不会刷盘，由系统自己决定什么时候刷盘，可能会丢失数据。</p></li><li><p>1（实时写）：每次提交事务，都会刷盘，性能较差。</p></li><li><p>N（延迟写）：提交N个事务后，才会刷盘。</p></li></ul><p>接下来可以完善一下上面的redolog提交事务的图：</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407183824785.png"></p><h3 id="关于两阶段提交"><a href="#关于两阶段提交" class="headerlink" title="关于两阶段提交"></a>关于两阶段提交</h3><div class="note note-danger">            <p>为什么需要两阶段提交？</p>          </div><ul><li><p>为了解决两个日志之间<strong>逻辑一致</strong>的问题。</p><ul><li>如果redolog写完之后，binlog写入时发生了异常，导致binlog和redolog之间的逻辑不一致</li><li>如果采用两阶段提交，就可以感知到写入binlog时发生了异常，后续再进行回滚或是别的补偿操作即可<ul><li>写入binlog时如果发生了异常，MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应bin log日志，就会回滚该事务</li></ul></li></ul></li><li><p>如果是redolog commit阶段发生了异常，则不会回滚事务，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的bin log日志，所以MySQL认为是完整的，就会提交事务恢复数据</p></li></ul><h3 id="系统崩溃后重启如何刷新数据？"><a href="#系统崩溃后重启如何刷新数据？" class="headerlink" title="系统崩溃后重启如何刷新数据？"></a>系统崩溃后重启如何刷新数据？</h3><ul><li>写入undo log之前崩溃：这时undo log和bin log中都没有数据，此时满足数据一致性不需要进行操作</li><li>写入bin log之前崩溃：此时根据undo log中的事务id去bin log中查找是没有数据的，因此会回滚</li><li>写入bin log之后崩溃：无论redo log有没有修改为commit状态，都会把数据更新到磁盘</li></ul><p>这种机制确保了在MySQL主从复制架构中，即使在某个阶段MySQL宕机，也可以在恢复时根据redo log和binlog的状态来决定是否提交或回滚事务，从而保证了主从机的数据一致性。</p><h2 id="4、主从复制"><a href="#4、主从复制" class="headerlink" title="4、主从复制"></a>4、主从复制</h2><p>MySQL的主从复制依赖于bin log，也就是<strong>记录MySQL上的所有变化</strong>并<strong>以二进制形式保存在磁盘</strong>上。</p><p>复制过程：将binlog中的数据从主库传输到从库（异步操作）</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407190151841.png"></p><p>MySQL集群的主从复制过程梳理成3个阶段：</p><ol><li>写入Bin log：主库写bin log日志，提交事务，并更新本地存储数据</li><li>同步Bin log：把bin log复制到所有从库上，每个从库把bin log写到暂存日志中</li><li>回放Bin log：回放bin log，并更新存储引擎中的数据</li></ol><blockquote><p>关于MySQL的集群，埋个坑。。。</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>保证即使数据库发生异常重启，之前提交的记录都不会丢失的能力，我们称为<strong>crash-safe</strong><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Zset</title>
    <link href="/2025/04/07/Redis-Zset/"/>
    <url>/2025/04/07/Redis-Zset/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍 Redis Zset 的底层数据结构实现即原理。</p></blockquote><p>zset底层在数据少的时候是压缩列表，数据量多了会进化成跳表。</p><h1 id="什么时候用压缩列表，什么时候用跳表？"><a href="#什么时候用压缩列表，什么时候用跳表？" class="headerlink" title="什么时候用压缩列表，什么时候用跳表？"></a>什么时候用压缩列表，什么时候用跳表？</h1><p>压缩列表使用要求：</p><ul><li>有序集合保存的元素<strong>数量小于128个</strong></li><li>有序集合保存的所有元素<strong>长度小于64字节</strong><br>  如果不满足以上两个条件之一，则进化成跳表</li></ul><h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表底层就是<strong>有序数组 + 标识符</strong>，标识符包括：列表长度、尾部偏移量、列表元素个数、列表结束标识符：</p><ul><li><strong>列表长度</strong>：保存整个压缩列表占用的内存字节数</li><li><strong>尾部偏移量</strong>：保存压缩列表起始地址到最后一个节点的字节数，可以快速定位到最后一个节点</li><li><strong>列表元素个数</strong>：保存压缩列表的节点个数</li><li><strong>列表结束标识符</strong>：特殊值0xFF（十进制为255），表示压缩列表的结束</li></ul><p>压缩列表结构：<br><img src="/2025/04/07/Redis-Zset/1.png"></p><ul><li>如果查找定位第一个元素和最后一个元素：时间复杂度为 <code>O(1)</code> - 通过表头三个字段直接定位</li><li>查找其他元素只能逐个查找：时间复杂度为 <code>O(n)</code></li></ul><h1 id="为什么用跳表？"><a href="#为什么用跳表？" class="headerlink" title="为什么用跳表？"></a>为什么用跳表？</h1><p>跳表是在<strong>有序链表</strong>的基础上进化而来的，它结合了：</p><ol><li><p><strong>链表</strong>在内存空间中不需要一块连续的区域</p></li><li><p><strong>有序数组</strong>的高效的查找算法：二分查找</p></li></ol><p>  两个优点。具体来说，<em>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现了数据的快速定位。</em> 如下：<br>  <img src="/2025/04/07/Redis-Zset/NeatReader-1743990195139.png" alt="NeatReader-1743990195139"></p><ul><li>跳表在链表的基础上增加了多级索引以提升查找的效率，其实是一个<strong>空间换时间</strong>的方案，必然会带来一个问题：索引是占内存的</li><li>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略</li></ul><h1 id="跳表的具体实现"><a href="#跳表的具体实现" class="headerlink" title="跳表的具体实现"></a>跳表的具体实现</h1><h2 id="1、普通的有序单向链表"><a href="#1、普通的有序单向链表" class="headerlink" title="1、普通的有序单向链表"></a>1、普通的有序单向链表</h2><p><img src="/2025/04/07/Redis-Zset/20250407094915.png"></p><p>如果我们需要查找节点33，需要从头节点开始一个个遍历，遍历6次，时间复杂度为 <code>O(n)</code></p><h2 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h2><p>我们在以上的有序单向链表的上一层，再添加一个一级索引：<br><img src="/2025/04/07/Redis-Zset/20250407095240.png" alt="Pasted image 20250407095240"></p><ul><li>查找节点33，遍历顺序为：<code>1 -&gt; 11 -&gt; 27 -&gt; 33</code>，一共遍历4次</li></ul><p>如果再向上添加一级索引：<br><img src="/2025/04/07/Redis-Zset/20250407095612.png"></p><ul><li>查找节点33，遍历顺序为：<code>1 -&gt; 27 -&gt; 33</code>，只需要遍历3次</li></ul><h1 id="索引建立时机"><a href="#索引建立时机" class="headerlink" title="索引建立时机"></a>索引建立时机</h1><p>前面提到，跳表的实现还是<strong>基于有序数组的二分查找</strong>来实现的，具体如下：<br>我们在新加一个节点的时候，可以考虑一下，现在最多有几层索引，如果现在一层都没有，上来就建了8层，就很没有必要，索引新加一个节点最好最多再往上建立一层索引，那么具体多少层，可以这么想，在第一层建立的概率是1&#x2F;2，第二层建立的概率是1&#x2F;4，第三层建立的概率是1&#x2F;8……</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (level &lt; maxLevel &amp;&amp; Math.random() &gt; <span class="hljs-number">0.5</span>) &#123;        level++;    &#125;    <span class="hljs-keyword">return</span> level;&#125;</code></pre></div><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;      <span class="hljs-comment">// 随机因子，这里设置成0.5</span>    <span class="hljs-type">double</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5d</span>;        <span class="hljs-comment">// 最大层级  </span>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;        <span class="hljs-comment">// 当前最大层级  </span>    <span class="hljs-type">int</span> <span class="hljs-variable">currentMaxLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(maxLevel, -<span class="hljs-number">1</span>);        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;          <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;          <span class="hljs-comment">// 从最大层开始查找，找到前一节点，通过--i，移动到下层再开始查找  </span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;              <span class="hljs-keyword">while</span> (p.nextNodes[i] != <span class="hljs-literal">null</span> &amp;&amp; p.nextNodes[i].value &lt; value) &#123;                  <span class="hljs-comment">// 找到前一节点  </span>                p = p.nextNodes[i];              &#125;          &#125;            <span class="hljs-keyword">if</span> (p.nextNodes[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span> &amp;&amp; p.nextNodes[<span class="hljs-number">0</span>].value == value) &#123;              <span class="hljs-keyword">return</span> p.nextNodes[<span class="hljs-number">0</span>];          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;          <span class="hljs-comment">// level代表这个节点存在于几层链表中  </span>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> randomLevel();          <span class="hljs-keyword">if</span> (level &gt; currentMaxLevel) &#123;              level = ++currentMaxLevel;          &#125;          <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(level, value);          <span class="hljs-type">Node</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> head;          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> currentMaxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;              <span class="hljs-comment">// 如果当前节点当前层级的下一个节点不为空，且比下一个节点的值小  往下走  </span>            <span class="hljs-keyword">while</span> (point.nextNodes[i] != <span class="hljs-literal">null</span> &amp;&amp; point.nextNodes[i].value &lt; value) &#123;                  point = point.nextNodes[i];              &#125;              <span class="hljs-comment">// 节点层级比当前层级大，在该层级插入该节点   之后继续遍历  </span>            <span class="hljs-keyword">if</span> (level &gt; i) &#123;                  <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> point.nextNodes[i];                  point.nextNodes[i] = newNode;                  newNode.nextNodes[i] = temp;              &#125;          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;        <span class="hljs-comment">// 随机层级，如果生成的概率&gt;0.5，就level++  </span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;          <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;          <span class="hljs-keyword">while</span> (level &lt; maxLevel &amp;&amp; Math.random() &gt; factor) &#123;              level++;          &#125;          <span class="hljs-keyword">return</span> level;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAll</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;          <span class="hljs-keyword">if</span> (level &gt; currentMaxLevel) &#123;              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;还没有到这个层数&quot;</span>);          &#125;          <span class="hljs-type">Node</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> head;          <span class="hljs-keyword">while</span> (point.nextNodes[level - <span class="hljs-number">1</span>] != <span class="hljs-literal">null</span>) &#123;              System.out.print(point.nextNodes[level - <span class="hljs-number">1</span>] + <span class="hljs-string">&quot; &quot;</span>);              point = point.nextNodes[level - <span class="hljs-number">1</span>];          &#125;          System.out.println();      &#125;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;          <span class="hljs-comment">// 节点值  </span>        <span class="hljs-type">int</span> value;            <span class="hljs-comment">/**  </span><span class="hljs-comment">         * 这个节点在某一层的下一个节点的集合，比如nextNodes[2]就是node在第二层的下一个节点  </span><span class="hljs-comment">         */</span>          Node[] nextNodes;            <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">int</span> value)</span> &#123;              nextNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[level];              <span class="hljs-built_in">this</span>.value = value;          &#125;            <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +                      <span class="hljs-string">&quot;value=&quot;</span> + value +                      <span class="hljs-string">&#x27;&#125;&#x27;</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">SkipList</span> <span class="hljs-variable">skipList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipList</span>();          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;              skipList.insert(i);          &#125;          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> skipList.currentMaxLevel; i &gt; <span class="hljs-number">0</span>; i--) &#123;              skipList.printAll(i);          &#125;      &#125;  &#125;</code></pre></div><h1 id="为什么不使用红黑树？"><a href="#为什么不使用红黑树？" class="headerlink" title="为什么不使用红黑树？"></a>为什么不使用红黑树？</h1><ol><li>虽然跳表消耗较多的内存，但是我们内部优化过跳表，可以接受。</li><li>跳表的实现很简单，至少比红黑树简单的多。</li><li>多范围查询的支持，跳表完胜红黑树。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
