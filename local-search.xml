<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>回溯个人总结：棋盘问题</title>
    <link href="/2025/04/20/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
    <url>/2025/04/20/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>题目链接附上：</p><p><a href="https://leetcode.cn/problems/n-queens/description/">51. N皇后</a></p><p><a href="https://leetcode.cn/problems/sudoku-solver/description/">37. 解数独</a></p><h1 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h1><h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/queens.jpg"><br><strong>输入：</strong> <code>n = 4</code><br><strong>输出：</strong> <code>[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</code><br>**解释：**如上图所示，4 皇后问题存在两个不同的解法。</p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>n = 1</code><br><strong>输出：</strong> <code>[[&quot;Q&quot;]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 9</code></li></ul><hr><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>画出树形结构：</p><p><img src="/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/image-20250420184937235.png"></p><p>棋盘问题有点复杂，让我们再回归回溯三部曲haha</p><h3 id="1、确定回溯函数模版以及返回参数"><a href="#1、确定回溯函数模版以及返回参数" class="headerlink" title="1、确定回溯函数模版以及返回参数"></a>1、确定回溯函数模版以及返回参数</h3><p>全局变量：</p><ul><li><code>List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</code></li></ul><p>局部变量：</p><ul><li>棋盘问题里，我们需要有一个棋盘二维数组，用来记录每次遍历后的棋盘的摆放（其实也就相当于一维回溯问题的 <code>list</code> 集合）：<ul><li><code>char[][] chessboard = new char[n][n];</code></li></ul></li><li><code>chessboard</code> 初始化为：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) &#123;    Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);&#125;</code></pre></div><ul><li>同时，还需要有 <code>row</code>，用来控制当前摆放到第几行了</li></ul><h3 id="2、确定回溯函数终止条件"><a href="#2、确定回溯函数终止条件" class="headerlink" title="2、确定回溯函数终止条件"></a>2、确定回溯函数终止条件</h3><p>终止条件即：摆放完第三行棋盘</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (row == n) &#123;    res.add(Array2List(chessboard));    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List <span class="hljs-title function_">Array2List</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> &#123;    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) &#123;        <span class="hljs-comment">// 把char转换成String之后加入到list里</span>        list.add(String.copyValueOf(c));    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></div><h3 id="3、分析回溯搜索的遍历过程"><a href="#3、分析回溯搜索的遍历过程" class="headerlink" title="3、分析回溯搜索的遍历过程"></a>3、分析回溯搜索的遍历过程</h3><p>再附上树形结构图：</p><p><img src="/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/image-20250420184932210.png"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>; col&lt;n; col++) &#123;    <span class="hljs-keyword">if</span> (isValid(row, col, chessboard, n)) &#123;   <span class="hljs-comment">// 验证是否合法，如果合法，直接放</span>        chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;   <span class="hljs-comment">// 放皇后</span>        backTracking(n, row+<span class="hljs-number">1</span>, chessboard);        chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;   <span class="hljs-comment">// 回溯</span>    &#125;&#125;</code></pre></div><p>合法条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-comment">// 不用判断同行，具体可以看树形结构图</span>    <span class="hljs-comment">// 是否同列</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;row; i++) &#123;        <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;        <span class="hljs-comment">// 判断45°方向</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>; i--, j--) &#123;        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;        <span class="hljs-comment">// 判断135°方向</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col+<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;n; i--, j++) &#123;        <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="整合答案"><a href="#整合答案" class="headerlink" title="整合答案"></a>整合答案</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-type">char</span>[][] chessboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;   <span class="hljs-comment">// 初始化</span>            Arrays.fill(chessboard[i], <span class="hljs-string">&#x27;.&#x27;</span>);        &#125;        backTracking(n, <span class="hljs-number">0</span>, chessboard);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, <span class="hljs-type">char</span>[][] chessboard)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (row == n) &#123;            res.add(Array2List(chessboard));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>; col&lt;n; col++) &#123;            <span class="hljs-keyword">if</span> (isValid(row, col, chessboard, n)) &#123;                chessboard[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;                backTracking(n, row+<span class="hljs-number">1</span>, chessboard);                chessboard[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">Array2List</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] chessboard)</span> &#123;        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] c : chessboard) &#123;            list.add(String.copyValueOf(c));        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">char</span>[][] chessboard, <span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-comment">// 列</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;row; i++) &#123;            <span class="hljs-keyword">if</span> (chessboard[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 45°</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>; i--, j--) &#123;            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 135°</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=row-<span class="hljs-number">1</span>, j=col+<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; j&lt;n; i--, j++) &#123;            <span class="hljs-keyword">if</span> (chessboard[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需 <strong>遵循如下规则</strong>：</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>示例 1：</strong></p><p><img src="/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/250px-sudoku-by-l2g-20050714svg.png"><br><strong>输入：</strong> <code>board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</code><br><strong>输出：</strong> <code>[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]</code><br><strong>解释：</strong> 输入的数独如上图所示，唯一有效的解决方案如下所示：</p><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li><li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li></ul><hr><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>树形结构上：</p><p><img src="/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/2020111720451790-20230310131816104.png"></p><p>和 <a href="https://leetcode.cn/problems/n-queens/description/">51. N皇后</a> 不同，上题只需要遍历每一行，每一行寻找一个合法的位置放置皇后即可；而这题是需要遍历<u>每一行中的每一个位置</u>，判断当前位置填入哪个数字是合法的</p><p>上回溯三部曲：</p><h3 id="1、确定回溯函数模版以及返回参数-1"><a href="#1、确定回溯函数模版以及返回参数-1" class="headerlink" title="1、确定回溯函数模版以及返回参数"></a>1、确定回溯函数模版以及返回参数</h3><p>首先，回溯函数的返回值应该是bool类型（之前是不是也遇到过这种情况？）</p><ul><li>解数独找到一个符合的条件，就立刻返回</li><li><code>public boolean backTracking(char[][] board)</code></li></ul><h3 id="2、确定回溯函数终止条件-1"><a href="#2、确定回溯函数终止条件-1" class="headerlink" title="2、确定回溯函数终止条件"></a>2、确定回溯函数终止条件</h3><p>本题不需要终止条件，因为解数独要遍历整个树形结构寻找可能的叶子节点就立刻返回</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯个人总结：关于去重</title>
    <link href="/2025/04/17/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8E%BB%E9%87%8D/"/>
    <url>/2025/04/17/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8E%BB%E9%87%8D/</url>
    
    <content type="html"><![CDATA[<p>关于前面做到的需要去重的回溯问题：</p><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a></p><p><a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II</a></p><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491. 非递减子序列</a></p><p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II</a></p><p>对比题目可以发现，需要去重的问题有以下几个特点：</p><ol><li>给出的输入集合包含<strong>重复元素</strong></li><li>输入集合的顺序不重要（可以重新排序）</li><li>输出的集合不能包含重复的集合</li></ol><hr><p>去重的两种方式：</p><ol><li><code>used[]</code> 数组</li><li>自己控制 <code>index</code> 进行去重</li></ol><p>以 <a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a> 举例：</p><h2 id="1、used-数组"><a href="#1、used-数组" class="headerlink" title="1、used[] 数组"></a>1、<code>used[]</code> 数组</h2><p><img src="/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%8E%BB%E9%87%8D/2183605283.png"></p><p>我们需要去重的是：树里面<strong>同一层</strong>出现的重复元素</p><p>所以当 <code>candidates[i-1]==candidates[i] &amp;&amp; used[i-1]==0</code> 时，直接continue。当然，还需要加上 <code>i&gt;0</code> 这个条件</p><ul><li>为什么是 <code>used[i-1] == 0</code>？<ul><li>因为我们要比较的是同一层的上一个节点 -&gt; 也就是回溯回去后得到的节点，这时候我们已经把 <code>used[i-1]</code> 置为0了，所以应该是 <code>used[i-1] == 0</code></li><li>如果我们需要找的是上一层的上一个节点，那么应该是 <code>used[i-1] == 1</code></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-type">int</span>[] used;        <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[candidates.length];        Arrays.fill(used, <span class="hljs-number">0</span>);        <span class="hljs-comment">// [1,1,2,5,6,7,10]</span>        Arrays.sort(candidates);        backTracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span> &#123;        <span class="hljs-keyword">if</span> (target == sum) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;candidates.length; i++) &#123;            <span class="hljs-comment">// 去重</span>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; candidates[i-<span class="hljs-number">1</span>]==candidates[i] &amp;&amp; used[i-<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 剪枝</span>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">break</span>;            list.add(candidates[i]);            used[i] = <span class="hljs-number">1</span>;            backTracking(candidates, target, i+<span class="hljs-number">1</span>, sum+candidates[i]);            list.remove(list.size()-<span class="hljs-number">1</span>);            used[i] = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="2、用index控制去重时机"><a href="#2、用index控制去重时机" class="headerlink" title="2、用index控制去重时机"></a>2、用index控制去重时机</h2><p><code>i &gt; index</code> 时也就是说当前遍历的节点不是根节点，那么就可以直接判断该节点是否和上一个节点一样，如果一样，直接continue</p><p>这个比 <code>used[]</code> 数组方便很多：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-comment">// [1,1,2,5,6,7,10]</span>        Arrays.sort(candidates);        backTracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span> &#123;        <span class="hljs-keyword">if</span> (target == sum) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;candidates.length; i++) &#123;            <span class="hljs-comment">// 去重</span>            <span class="hljs-keyword">if</span> (i&gt;index &amp;&amp; candidates[i-<span class="hljs-number">1</span>]==candidates[i]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 剪枝</span>            <span class="hljs-keyword">if</span> (sum + candidates[i] &gt; target) <span class="hljs-keyword">break</span>;            list.add(candidates[i]);            backTracking(candidates, target, i+<span class="hljs-number">1</span>, sum+candidates[i]);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯个人总结：排列问题</title>
    <link href="/2025/04/17/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2025/04/17/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h1><p>题目链接附上：</p><p><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></p><p><a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II</a></p><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong><br><strong>输入：</strong> <code>nums = [1,2,3]</code><br><strong>输出：</strong> <code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>nums = [0,1]</code><br><strong>输出：</strong> <code>[[0,1],[1,0]]</code></p><p><strong>示例 3：</strong><br><strong>输入：</strong> <code>nums = [1]</code><br><strong>输出：</strong> <code>[[1]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><hr><p>层级结构：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/7091213359.png"></p><p>由图上可知，我们取每棵树的叶子节点加入到结果集，并且每个节点的选取都是从数组的第一个元素开始顺序选取，所以我们需要添加一个 <code>used[]</code> 数组，用来跳过该循环中已经遍历过的元素。</p><p>根据它和组合型问题的不同，我们需要改变几个小地方：</p><ol><li><u>不需要再用 <code>index</code> 来控制每次树中节点的遍历位置</u>，因为每一次循环中，每一个元素都需要遍历</li><li>添加 <code>used[]</code> 数组，用来控制该次循环中已经遍历过的元素</li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-type">int</span>[] used;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];        Arrays.fill(used, <span class="hljs-number">0</span>);        backTracking(nums);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (list.size() == nums.length) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            list.add(nums[i]);            used[i] = <span class="hljs-number">1</span>;            backTracking(nums);            list.remove(list.size()-<span class="hljs-number">1</span>);            used[i] = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong><br><strong>输入：</strong> <code>nums = [1,1,2]</code><br><strong>输出：</strong> <code>[[1,1,2],[1,2,1],[2,1,1]]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>nums = [1,2,3]</code><br><strong>输出：</strong> <code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 8</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><hr><p>和上题不同的是，输入数组有重复元素，所以输出需要<strong>去重</strong></p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/7094045666.png"></p><p>和之前的去重方式一样，先对输入数组进行排序，再利用 <code>used[]</code> 数组去重即可：</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-type">int</span>[] used;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];        Arrays.fill(used, <span class="hljs-number">0</span>);        Arrays.sort(nums);        backTracking(nums);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (list.size() == nums.length) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;nums.length; i++) &#123;            <span class="hljs-comment">// 跳过已遍历的元素</span>            <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 去重</span>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i-<span class="hljs-number">1</span>] &amp;&amp; used[i-<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            list.add(nums[i]);            used[i] = <span class="hljs-number">1</span>;            backTracking(nums);            list.remove(list.size()-<span class="hljs-number">1</span>);            used[i] = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre></div><h1 id="尝试总结"><a href="#尝试总结" class="headerlink" title="尝试总结"></a>尝试总结</h1><p>排列问题和组合问题不同的是，它不需要用 <code>index</code> 来控制每次遍历的数组下标，因为每一次遍历都需要遍历完全部数组，当 <code>list</code> 集合的大小和数组大小相等，则达到终止条件，加入到结果集，返回即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯个人总结：子集问题</title>
    <link href="/2025/04/14/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/"/>
    <url>/2025/04/14/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><p>题目链接附上：</p><p><a href="https://leetcode.cn/problems/subsets/description/">78. 子集</a></p><p><a href="https://leetcode.cn/problems/subsets-ii/description/">90. 子集 II</a></p><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">491. 非递减子序列</a></p><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong><br>**输入： **<code>nums = [1,2,3]</code><br><strong>输出：</strong><code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>nums = [0]</code><br><strong>输出：</strong> <code>[[],[0]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><hr><p>根据测试用例的示例1，画出层级结构：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/4144416023.png"></p><p>从图上可以看出，和组合问题、切割问题不同的是，之前遇到的两类问题都是需要将树结构里的每个叶子节点加入到结果集，而子集问题是需要将树结构中的<strong>所有节点（叶子+非叶子）</strong> 加入到结果集（包括空集，所以把原本的三组树集合成了一个共同祖先，共同祖先也需要加入到结果集）</p><p>很好处理，把加入到结果集的处理从终止条件的 <code>if</code> 里面放到外面，<u>一进入回溯函数就添加到结果集</u>即可：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        backTracking(nums, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-comment">// 树上每一个节点的值都要保存到结果集</span>        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (index == nums.length) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;nums.length; i++) &#123;            list.add(nums[i]);            backTracking(nums, i+<span class="hljs-number">1</span>);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong><br><strong>输入：</strong> <code>nums = [1,2,2]</code><br><strong>输出：</strong> <code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>nums = [0]</code><br><strong>输出：</strong> <code>[[],[0]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li></ul><hr><p>和上题不同的是，题目里给出的集合有重复元素，而结果集需要去重</p><p>去重方法和<a href="https://feiyeee.github.io/2025/04/12/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII">组合问题：40. 组合总和 II</a>是一样的，不再赘述：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        Arrays.sort(nums);        backTracking(nums, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));        <span class="hljs-keyword">if</span> (index == nums.length) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;nums.length; i++) &#123;            <span class="hljs-comment">// 去重条件</span>            <span class="hljs-keyword">if</span> (i&gt;index &amp;&amp; nums[i-<span class="hljs-number">1</span>]==nums[i]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            list.add(nums[i]);            backTracking(nums, i+<span class="hljs-number">1</span>);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h2 id="491-非递减子序列"><a href="#491-非递减子序列" class="headerlink" title="491. 非递减子序列"></a>491. 非递减子序列</h2><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p><p><strong>示例 1：</strong><br><strong>输入：</strong> <code>nums = [4,6,7,7]</code><br><strong>输出：</strong> <code>[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>nums = [4,4,3,2,1]</code><br><strong>输出：</strong> <code>[[4,4]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 15</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><hr><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/4152829154.png"></p><p>根据题意，这题也是需要去重的，但是和之前遇到的去重问题不一样，之前都是基于对原数组进行排序后再去重，但<strong>本题不可以对原数组排序</strong></p><p>根据画出来的树形结构，当我们准备取的数在本层的之前就已经被取过了的话，那么就不可以取了，直接 <code>continue</code></p><p>剩下别的限制条件，根据题意很容易得出来，参考答案如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">findSubsequences</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res;        backTracking(nums, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-keyword">if</span> (list.size() &gt; <span class="hljs-number">1</span>) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));        &#125;        <span class="hljs-comment">// 用set去重</span>        HashSet&lt;Integer&gt; uset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(!list.isEmpty() &amp;&amp; list.get(list.size()-<span class="hljs-number">1</span>)&gt;nums[i] || uset.contains(nums[i]))                <span class="hljs-keyword">continue</span>;            uset.add(nums[i]);            list.add(nums[i]);            backTracking(nums, i+<span class="hljs-number">1</span>);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h1 id="尝试总结"><a href="#尝试总结" class="headerlink" title="尝试总结"></a>尝试总结</h1><p>子集问题相比于组合问题来说，步骤思路基本一致，先画出树形结构，而：</p><ul><li>组合问题将树形结构的叶子节点加入到结果集</li><li>子集问题将树形结构的<strong>所有节点（叶子 + 非叶子 节点）</strong> 加入到结果集</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC序列化: 对象怎么在网络中传输？</title>
    <link href="/2025/04/13/RPC%E5%BA%8F%E5%88%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E6%80%8E%E4%B9%88%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E4%BC%A0%E8%BE%93%EF%BC%9F/"/>
    <url>/2025/04/13/RPC%E5%BA%8F%E5%88%97%E5%8C%96-%E5%AF%B9%E8%B1%A1%E6%80%8E%E4%B9%88%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E4%BC%A0%E8%BE%93%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么需要序列化？"><a href="#为什么需要序列化？" class="headerlink" title="为什么需要序列化？"></a>为什么需要序列化？</h1><p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是不能直接在网络中传输的，所以我们需要提前把它<u>转成可传输的二进制</u>，并且<u>要求转换算法是可逆的</u>，这个过程我们一般叫做 <strong>“序列化”</strong>。 这时，服务提供方就可以正确地从二进制数据中分割出不同的请求，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，这个过程我们称之为“反序列化”。</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/8032d6995be27c0596a6610a48.png" alt="序列化与反序列化"></p><h1 id="有哪些常用的序列化？"><a href="#有哪些常用的序列化？" class="headerlink" title="有哪些常用的序列化？"></a>有哪些常用的序列化？</h1><h2 id="JDK原生序列化"><a href="#JDK原生序列化" class="headerlink" title="JDK原生序列化"></a>JDK原生序列化</h2><ul><li>序列化的具体实现：ObjectOutputStream</li><li>反序列化的具体实现：ObjectInputStream</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-comment">// 学号</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> no;    <span class="hljs-comment">// 姓名</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> no;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;        <span class="hljs-built_in">this</span>.no = no;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +                <span class="hljs-string">&quot;no=&quot;</span> + no +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 获取系统属性：C:\Users\VGB</span>        <span class="hljs-type">String</span> <span class="hljs-variable">home</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>);        <span class="hljs-type">String</span> <span class="hljs-variable">basePath</span> <span class="hljs-operator">=</span> home + <span class="hljs-string">&quot;/Desktop&quot;</span>;        <span class="hljs-comment">// 文件输出流</span>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(basePath + <span class="hljs-string">&quot;student.dat&quot;</span>);        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();        student.setNo(<span class="hljs-number">100</span>);        student.setName(<span class="hljs-string">&quot;TEST_STUDENT&quot;</span>);        <span class="hljs-comment">// 对象输出流</span>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fos);        oos.writeObject(student);        oos.flush();        oos.close();                <span class="hljs-comment">// 文件输入流</span>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(basePath + <span class="hljs-string">&quot;student.dat&quot;</span>);        <span class="hljs-comment">// 对象输入流</span>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fis);        <span class="hljs-comment">// 读对象，获取</span>        <span class="hljs-type">Student</span> <span class="hljs-variable">deStudent</span> <span class="hljs-operator">=</span> (Student) ois.readObject();        ois.close();        System.out.println(deStudent);    &#125;&#125;</code></pre></div><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/20250414153845896.png"></p><p>JDK的序列化过程：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/389acb1ef04e56f8ea9e7bcb5c.png" alt="ObjectOutputStream序列化过程图"></p><p>序列化过程就是在读取对象数据的时候，不断<u>加入一些特殊分隔符</u>，这些特殊分隔符<u>用于在反序列化过程中截断用</u>。</p><ol><li>头部数据：声明<strong>序列化协议</strong>、<strong>序列化版本</strong>，用于高低版本向后兼容</li><li>对象数据主要包括：<strong>类名</strong>、<strong>签名</strong>、<strong>属性名</strong>、<strong>属性类型</strong>及<strong>属性值</strong>，当然还有开头结尾等数据，除了属性值属于真正的对象值，其他都是为了反序列化用的元数据</li><li>存在对象引用、继承的情况下，就是递归遍历“写对象”逻辑</li></ol><p>实际上任何一种序列化框架，核心思想就是<u>设计一种序列化协议，将对象的类型、属性类型、属性值一一按照固定的格式<strong>写到二进制字节流中</strong>来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息<strong>重新创建出一个新的对象</strong>，来完成反序列化</u>。</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>应用广泛，但存在问题：</p><ol><li>进行序列化的<strong>额外空间开销比较大</strong>，对于大数据量服务这意味着需要巨大的内存和磁盘开销</li><li>没有类型，但像 Java 这种强类型语言，需要通过反射统一解决，所以<strong>性能不会太好</strong></li></ol><p>所以如果 RPC 框架选用 JSON 序列化，服务提供者与服务调用者之间传输的<u>数据量要相对较小</u>，否则将严重影响性能。</p><h2 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();student.setNo(<span class="hljs-number">101</span>);student.setName(<span class="hljs-string">&quot;HESSIAN&quot;</span>);<span class="hljs-comment">// 把student对象转化为byte数组</span><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<span class="hljs-type">Hessian2Output</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Output</span>(bos);output.writeObject(student);output.flushBuffer();<span class="hljs-type">byte</span>[] data = bos.toByteArray();bos.close();<span class="hljs-comment">// 把刚才序列化出来的byte数组转化为student对象</span><span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(data);<span class="hljs-type">Hessian2Input</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hessian2Input</span>(bis);<span class="hljs-type">Student</span> <span class="hljs-variable">deStudent</span> <span class="hljs-operator">=</span> (Student) input.readObject();input.close();System.out.println(deStudent);</code></pre></div><p>优点：</p><ul><li>动态类型、二进制、紧凑的</li><li>可跨语言移植的（兼容性、稳定性）</li><li>比 JDK、JSON 更加紧凑，性能上比 JDK、JSON 序列化高效很多，生成的字节数也更小</li></ul><p>问题：官方版本对 Java 里面一些常见对象的类型不支持</p><ol><li>Linked 系列，LinkedHashMap、LinkedHashSet 等，但是可以通过扩展 CollectionDeserializer 类修复</li><li>Locale 类，可以通过扩展 ContextSerializerFactory 类修复</li><li>Byte&#x2F;Short 反序列化的时候变成 Integer</li></ol><h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * // IDl 文件格式</span><span class="hljs-comment"> * synax = &quot;proto3&quot;;</span><span class="hljs-comment"> * option java_package = &quot;com.test&quot;;</span><span class="hljs-comment"> * option java_outer_classname = &quot;StudentProtobuf&quot;;</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * message StudentMsg &#123;</span><span class="hljs-comment"> * //序号</span><span class="hljs-comment"> * int32 no = 1;</span><span class="hljs-comment"> * //姓名</span><span class="hljs-comment"> * string name = 2;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span> StudentProtobuf.StudentMsg.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> StudentProtobuf.StudentMsg.newBuilder();builder.setNo(<span class="hljs-number">103</span>);builder.setName(<span class="hljs-string">&quot;protobuf&quot;</span>);<span class="hljs-comment">//把student对象转化为byte数组</span>StudentProtobuf.<span class="hljs-type">StudentMsg</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> builder.build();<span class="hljs-type">byte</span>[] data = msg.toByteArray();<span class="hljs-comment">//把刚才序列化出来的byte数组转化为student对象</span>StudentProtobuf.<span class="hljs-type">StudentMsg</span> <span class="hljs-variable">deStudent</span> <span class="hljs-operator">=</span> StudentProtobuf.StudentMsg.parseFrom(data);System.out.println(deStudent);</code></pre></div><p>优点：</p><ol><li>序列化后体积相比 JSON、Hessian <strong>小</strong>很多</li><li>IDL（Interface description language）能清晰地描述语义，所以足以<strong>帮助并保证应用程序之间的类型不会丢失</strong>，无需类似 XML 解析器</li><li>序列化反序列化<strong>速度很快</strong>，不需要通过反射获取类型</li><li>消息格式升级和<strong>兼容性</strong>不错，可以做到向后兼容</li></ol><p>缺点：</p><ul><li>对于具有反射和动态能力的语言来说，用起来很麻烦，比如Java，这时候可以考虑用Protostuff：<ul><li>Protostuff 不需要依赖 IDL 文件</li><li>可以直接对 Java 领域对象进行（反）序列化操作</li><li>效率上跟 Protobuf 差不多</li><li>生成的二进制格式和 Protobuf 完全相同</li></ul></li></ul><p>Protostuff问题：</p><ol><li>不支持null</li><li>不支持单纯的Map、List集合对象，需要包在对象里</li></ol><h1 id="RPC框架中如何选择序列化？"><a href="#RPC框架中如何选择序列化？" class="headerlink" title="RPC框架中如何选择序列化？"></a>RPC框架中如何选择序列化？</h1><p>考虑因素：</p><ul><li>性能</li><li>效率</li><li>空间开销（序列化后的二进制数据体积大小）</li><li><strong>通用性、兼容性</strong></li><li>安全性</li></ul><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/6693e26e72600ae4e4b49fb9b5.png" alt="序列化方式选取考虑因素及优先级"></p><p>综上，我们首选的还是 Hessian 与 Protobuf，因为他们在性能、时间开销、空间开销、通用性、兼容性和安全性上，都满足了我们的要求。</p><p>其中 <u>Hessian 在使用上更加方便，在对象的兼容性上更好；Protobuf 则更加高效，通用性上更有优势。</u></p><h1 id="RPC框架在使用时需要注意哪些问题？"><a href="#RPC框架在使用时需要注意哪些问题？" class="headerlink" title="RPC框架在使用时需要注意哪些问题？"></a>RPC框架在使用时需要注意哪些问题？</h1><p><strong>对象构造得过于复杂：</strong> 属性很多，并且存在多层的嵌套，比如 A 对象关联 B 对象，B 对象又聚合 C 对象，C 对象又关联聚合很多其他对象，对象依赖关系过于复杂。序列化框架在序列化与反序列化对象时，对象越复杂就越浪费性能，消耗 CPU，这会严重影响 RPC 框架整体的性能；另外，对象越复杂，在序列化与反序列化的过程中，出现问题的概率就越高。</p><p>**对象过于庞大： **我经常遇到业务过来咨询，为啥他们的 RPC 请求经常超时，排查后发现他们的入参对象非常得大，比如为一个大 List 或者大 Map，序列化之后字节长度达到了上兆字节。这种情况同样会严重地浪费了性能、CPU，并且序列化一个如此大的对象是很耗费时间的，这肯定会直接影响到请求的耗时。</p><p>**使用序列化框架不支持的类作为入参类： **比如 Hessian 框架，他天然是不支持 LinkHashMap、LinkedHashSet 等，而且大多数情况下最好不要使用第三方集合类，如 Guava 中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如 HashMap、ArrayList。</p><p>**对象有复杂的继承关系： **大多数序列化框架在序列化对象时都会将对象的属性一一进行序列化，当有继承关系时，会不停地寻找父类，遍历属性。就像问题 1 一样，对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。</p><p>在 RPC 框架的使用过程中，我们要<u>尽量构建简单的对象作为入参和返回值对象</u>，避免上述问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对象在网络之间传输、通信，是一定需要序列化的，而序列化的核心思想就是设计一种<strong>序列化协议</strong>，将对象的类型、属性类型、属性值一一按照固定的格式<strong>写到二进制字节流中</strong>来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息<strong>重新创建出一个新的对象</strong>，来完成反序列化。</p><p>市面上有很多序列化协议，而我们经评估后，序列化框架的<strong>安全性、通用性、兼容性</strong>是我们首要考虑的因素。综合考虑，Hessian 与 Protobuf是我们首选的序列化协议，Hessian的兼容性更好，而Protobuf更加高效，用户根据自己的需求考量进行选择即可。</p>]]></content>
    
    
    <categories>
      
      <category>RPC实战与核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯个人总结：切割问题</title>
    <link href="/2025/04/12/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2025/04/12/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="切割问题"><a href="#切割问题" class="headerlink" title="切割问题"></a>切割问题</h1><p>题目链接附上：</p><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></p><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></p><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些 子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>示例 1：</strong><br><strong>输入：</strong> <code>s = &quot;aab&quot;</code><br><strong>输出：</strong> <code>[[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>s = &quot;a&quot;</code><br>**输出： **<code>[[&quot;a&quot;]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 16</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><hr><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们可以把字符串 <code>s</code> 中的每一个字母后面都添加一个<strong>逗号</strong>，那么问题就转换成了 <strong>”选或不选“</strong> 的问题：（图中的 ”。“ 表示待选择的位置）</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/2225739170.png"></p><p>关于回溯函数的参数、终止条件都很常规，这里不赘述</p><p>我们主要来探究回溯循环该怎么写</p><p>可以参照上图，如果我们选择了这个逗号，就判断这样分割之后这个子串是不是回文串</p><ul><li>如果是，就选，加入到list，继续回溯</li><li>如果不是，就不选，直接跳过</li></ul><p>附上：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;s.length(); i++) &#123;    <span class="hljs-comment">// 如果截取后是回文，选，加入list里</span>    <span class="hljs-keyword">if</span> (isHuiwen(s, index, i)) &#123;        list.add(s.substring(index, i+<span class="hljs-number">1</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">continue</span>;    &#125;    backTracking(s, i + <span class="hljs-number">1</span>);    list.remove(list.size()-<span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="完整答案"><a href="#完整答案" class="headerlink" title="完整答案"></a>完整答案</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(String s)</span> &#123;        backTracking(s, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (index == s.length()) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;s.length(); i++) &#123;            <span class="hljs-comment">// 如果截取后是回文，选，加入list里</span>            <span class="hljs-keyword">if</span> (isHuiwen(s, index, i)) &#123;                list.add(s.substring(index, i+<span class="hljs-number">1</span>));            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">continue</span>;            &#125;            backTracking(s, i + <span class="hljs-number">1</span>);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHuiwen</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;        <span class="hljs-keyword">while</span> (start &lt; end) &#123;            <span class="hljs-keyword">if</span> (s.charAt(start) != s.charAt(end)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            start++;            end--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p><ul><li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li></ul><p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p><p><strong>示例 1：</strong><br><strong>输入：</strong> <code>s = &quot;25525511135&quot;</code><br><strong>输出：</strong> <code>[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</code></p><p><strong>示例 2：</strong><br><strong>输入：</strong> <code>s = &quot;0000&quot;</code><br><strong>输出：</strong> <code>[&quot;0.0.0.0&quot;]</code></p><p><strong>示例 3：</strong><br><strong>输入：</strong> <code>s = &quot;101023&quot;</code><br><strong>输出：</strong> <code>[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code> </p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅由数字组成</li></ul><hr><p>这个同上题，把每个数字后面都加一个伪 <code>&quot;.&quot;</code>，将其转换成 <strong>“选或不选”</strong> 问题</p><p>不同的是，这个题还有一个限制条件，就是只能分割成四组数字，也就是说，有且仅有三个 <code>&quot;.&quot;</code></p><p>而且这里对字符串 <code>s</code> 原地做改变，比用 <code>StringBuffer</code> 要方便很多，所以对于最后一组的选择，我们实际上是不需要加上 <code>&quot;.&quot;</code> 的，所以把这个的合法条件放在循环里判断也很不方便，直接在终止条件里判断即可</p><p>答案附上：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;        backTracking(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> pointNum)</span> &#123;        <span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">if</span> (isValid(s, index, s.length()-<span class="hljs-number">1</span>)) &#123;                res.add(s);            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;s.length(); i++) &#123;            <span class="hljs-keyword">if</span> (isValid(s, index, i)) &#123;                s = s.substring(<span class="hljs-number">0</span>, i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.&quot;</span> + s.substring(i+<span class="hljs-number">1</span>);                pointNum++;                backTracking(s, i+<span class="hljs-number">2</span>, pointNum);                s = s.substring(<span class="hljs-number">0</span>, i+<span class="hljs-number">1</span>) + s.substring(i+<span class="hljs-number">2</span>);                pointNum--;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 控制的条件：</span>    <span class="hljs-comment">//   1、只能有三个 &quot;.&quot;</span>    <span class="hljs-comment">//   2、每个整数在0~255之间</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-keyword">if</span> (i &gt; j) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (s.charAt(i)==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; i!=j) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m=i; m&lt;=j; m++) &#123;            <span class="hljs-keyword">if</span> (s.charAt(m) &lt; <span class="hljs-string">&#x27;0&#x27;</span> || s.charAt(m) &gt; <span class="hljs-string">&#x27;9&#x27;</span>) &#123;                <span class="hljs-comment">// 非法数字</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            num = num*<span class="hljs-number">10</span> + (s.charAt(m)-<span class="hljs-string">&#x27;0&#x27;</span>);            <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><h1 id="尝试总结"><a href="#尝试总结" class="headerlink" title="尝试总结"></a>尝试总结</h1><p>切割问题可以转换成（不可重复选的）组合问题</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯个人总结：组合问题</title>
    <link href="/2025/04/12/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <url>/2025/04/12/%E5%9B%9E%E6%BA%AF%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>算是个人刷代码随想录的个人总结吧</p>          </div><h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><p>回溯三部曲：</p><ol><li>确定回溯函数模版以及返回参数</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span></code></pre></div><ol start="2"><li>确定回溯函数终止条件</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (终止条件) &#123;存放结果;<span class="hljs-keyword">return</span>;&#125;</code></pre></div><ol start="3"><li>回溯搜索的遍历过程<br><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/1174.png" alt="层级结构"></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;    处理节点;    backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span>    回溯，撤销处理结果&#125;</code></pre></div><hr><p>回溯模版：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> &#123;    <span class="hljs-keyword">if</span> (终止条件) &#123;        存放结果;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span>        回溯，撤销处理结果    &#125;&#125;</code></pre></div><h1 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h1><p>题目链接附上：</p><p><a href="https://leetcode.cn/problems/combinations/description/">77. 组合</a></p><p><a href="https://leetcode.cn/problems/combination-sum-iii/description/">216. 组合总和 III</a></p><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合</a></p><p><a href="https://leetcode.cn/problems/combination-sum/description/">39. 组合总和</a></p><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II</a></p><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。<br>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例1：</strong><br><strong>输入：</strong> <code>n = 4, k = 2</code><br><strong>输出：</strong> <code>[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]</code></p><p><strong>示例2：</strong><br><strong>输入：</strong> <code>n = 1, k = 1</code><br><strong>输出：</strong> <code>[[1]]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><hr><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>按照示例1的测试用例，画出其层级结构如下：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/2173354982.png"></p><h3 id="1、确定回溯函数模版以及返回参数"><a href="#1、确定回溯函数模版以及返回参数" class="headerlink" title="1、确定回溯函数模版以及返回参数"></a>1、确定回溯函数模版以及返回参数</h3><p>全局变量：</p><ul><li>结果集：<code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</code></li><li>保存每一次遍历后得到的结果：<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></li></ul><p>函数参数：</p><p>因为我们每一次遍历都需要控制每一棵树（或子树）的root（如上图，三棵树的root分别为：1、2、3），所以传入回溯函数的参数里，除了n和k，还有index：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index)</span>;</code></pre></div><h3 id="2、确定回溯函数终止条件"><a href="#2、确定回溯函数终止条件" class="headerlink" title="2、确定回溯函数终止条件"></a>2、确定回溯函数终止条件</h3><p>终止条件：</p><ul><li>当list的大小正好等于k时，把结果添加到结果集，返回</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (list.size() == k) &#123;    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><ul><li>注意，这里需要新建一个ArrayList，因为list是全局变量，在递归中会重复使用，如果不新建一个ArrayList，后续对list的改变会影响到已经加入到结果集里的结果</li></ul><h3 id="3、分析回溯搜索的遍历过程"><a href="#3、分析回溯搜索的遍历过程" class="headerlink" title="3、分析回溯搜索的遍历过程"></a>3、分析回溯搜索的遍历过程</h3><p>再贴上此图：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/2173354982.png"></p><ul><li>一层一层看，每一层的节点个数就是<strong>for循环</strong>里要遍历的次数</li><li>从上往下看，树结构的层数，就是<strong>递归遍历</strong>的次数</li></ul><p>组合里的元素<strong>不可重复取</strong>（<code>[1, 2]</code> 和 <code>[2, 1]</code> 是同个组合），所以我们都只需要往后取元素，不用往前看。 </p><ul><li><code>index = 1</code> 时，就不需要取 <code>index - 1</code> 的元素了，因为 <code>index = 0</code> 时已经取过 <code>index + 1</code> 的元素了</li></ul><p>综上，构建出回溯循环：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;=n; i++) &#123;    <span class="hljs-comment">// 处理节点</span>    list.add(i);    <span class="hljs-comment">// 递归</span>    backTracking(n, k, i+<span class="hljs-number">1</span>);    <span class="hljs-comment">// 回溯</span>    list.remove(list.size()-<span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="初始答案"><a href="#初始答案" class="headerlink" title="初始答案"></a>初始答案</h3><p>附上：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;        backTracking(n, k, <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (list.size() == k) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;=n; i++) &#123;            list.add(i);            <span class="hljs-comment">// 回溯</span>            backTracking(n, k, i+<span class="hljs-number">1</span>);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><p>当我们<u>剩余可以取的元素已经小于我们需要取的元素时</u>，就可以跳出循环了<br>优化过程：</p><ol><li>已经选择的元素个数：<code>list.size();</code></li><li>还需要的元素个数为: <code>k - list.size();</code></li><li>在集合n中至多要从该起始位置 : <code>n - (k - list.size()) + 1</code>，开始遍历</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;        backTracking(n, k, <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (list.size() == k) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;=n-(k-list.size())+<span class="hljs-number">1</span>; i++) &#123;            list.add(i);            <span class="hljs-comment">// 回溯</span>            backTracking(n, k, i+<span class="hljs-number">1</span>);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><p>执行用时优化：<code>21ms -&gt; 19ms</code></p><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。<br><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例1：</strong><br><strong>输入：</strong> <code>candidates = [2,3,6,7], target = 7</code><br><strong>输出：</strong> <code>[[2,2,3],[7]]</code><br><strong>解释：</strong><br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p><p><strong>示例2：</strong><br><strong>输入:</strong> <code>candidates = [2,3,5], target = 8</code><br><strong>输出:</strong> <code>[[2,2,2,2],[2,3,3],[3,5]]</code></p><p><strong>示例3：</strong><br><strong>输入:</strong> <code>candidates = [2], target = 1</code><br><strong>输出:</strong> <code>[]</code></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><hr><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>这题和上一题不太一样的是，这题里的元素可以<strong>无限制重复被选取</strong></p><p>还是一样，根据测试用例1先画出层级结构：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/2180401183.png"></p><p>这层级结构一看，后面肯定是需要剪枝的。。但是我们先用纯暴力，把整体思路写出来</p><h3 id="1、确定回溯函数模版以及返回参数-1"><a href="#1、确定回溯函数模版以及返回参数-1" class="headerlink" title="1、确定回溯函数模版以及返回参数"></a>1、确定回溯函数模版以及返回参数</h3><p>全局变量：</p><ul><li>结果集：<code>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</code></li><li>保存每一次遍历后得到的结果：<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></li></ul><p>回溯函数参数：</p><p>和上一题一样，除了包括题目的输入里的两个参数，还有每棵树的root，我们用index控制；此外，我们要计算遍历到此的所有节点的总和，即 <code>sum</code></p><ul><li><code>int[] candidates</code></li><li><code>int target</code></li><li><code>int index</code></li><li><code>int sum</code></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span>;</code></pre></div><h3 id="2、确定回溯函数终止条件-1"><a href="#2、确定回溯函数终止条件-1" class="headerlink" title="2、确定回溯函数终止条件"></a>2、确定回溯函数终止条件</h3><ol><li>当 <code>sum &gt; target</code> 时，直接返回（当做剪枝了）</li><li>当 <code>sum == target</code> 时，添加到结果集再返回</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 终止条件</span><span class="hljs-keyword">if</span> (sum &gt; target) &#123;    <span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (sum == target) &#123;    res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><h3 id="3、分析回溯搜索的遍历过程-1"><a href="#3、分析回溯搜索的遍历过程-1" class="headerlink" title="3、分析回溯搜索的遍历过程"></a>3、分析回溯搜索的遍历过程</h3><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/2180401183.png"></p><p>前面提到，这题和上一题不太一样的是，这题里的元素可以<strong>无限制重复被选取</strong></p><p>如上图，树的每一层元素都是从第一个元素开始添加的，而这个是由for循环里的 <code>i</code> 来控制的，所以：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;candidates.length; i++) &#123;    list.add(candidates[i]);    backTracking(candidates, target, i, sum + candidates[i]);   <span class="hljs-comment">// 可以重复选取，不用i+1</span>    list.remove(list.size()-<span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>附上：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;        backTracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (sum &gt; target) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (sum == target) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;candidates.length; i++) &#123;            list.add(candidates[i]);            backTracking(candidates, target, i, sum + candidates[i]);   <span class="hljs-comment">// 可以重复选取，不用i+1</span>            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40. 组合总和II"></a>40. 组合总和II</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<br><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong> 解集不能包含重复的组合。 </p><p><strong>示例1：</strong><br><strong>输入:</strong> <code>candidates = [10,1,2,7,6,1,5], target = 8</code><br><strong>输出:</strong> <code>[[1,1,6],[1,2,5],[1,7],[2,6]]</code></p><p><strong>示例2：</strong><br><strong>输入:</strong> <code>candidates = [2,5,2,1,2], target = 5</code><br><strong>输出:</strong> <code>[[1,2,2],[5]]</code></p><p><strong>提示:</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 100</code></li><li><code>1 &lt;= candidates[i] &lt;= 50</code></li><li><code>1 &lt;= target &lt;= 30</code></li></ul><hr><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>和上题又有点不同的是：</p><ol><li>每个元素<strong>只能用一次</strong></li><li>结果集要<strong>去重</strong></li></ol><p>我们可以先把 <code>candidates</code> 排序，方便后续去重</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/2183605283.png"></p><p>从层级结构可以看出，当我们遍历到当前层已经遍历过了的元素，直接continue即可</p><p>如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-comment">// 排序</span>        Arrays.sort(candidates);        backTracking(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> sum)</span> &#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (sum &gt; target) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (sum == target) &#123;            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=index; i&lt;candidates.length; i++) &#123;            <span class="hljs-comment">// 对同一层已经使用过的元素跳过</span>            <span class="hljs-keyword">if</span> (i&gt;index &amp;&amp; candidates[i-<span class="hljs-number">1</span>]==candidates[i]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            list.add(candidates[i]);            backTracking(candidates, target, i+<span class="hljs-number">1</span>, sum+candidates[i]);            list.remove(list.size()-<span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><h1 id="尝试总结"><a href="#尝试总结" class="headerlink" title="尝试总结"></a>尝试总结</h1><p>组合问题里，即返回的结果集里<strong>没有顺序</strong>，<code>[1, 2]</code>和<code>[2, 1]</code>是一个组合，这组题目里还需要关注几种情况：</p><ol><li>可以重复选吗？<ul><li>不可重复选：<code>backTracking(i + 1)</code></li><li>需要重复选：<code>backTracking(i)</code></li></ul></li><li>每次处理完节点后还需要做什么别的操作吗？（比如计算总和）<ul><li>需要计算总和，需要多传入参数：<code>backTracking(i, sum + temp)</code></li></ul></li><li>会不会造成结果集重复的问题？<ul><li>要根据具体题目进行分析、去重</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL集群</title>
    <link href="/2025/04/10/MySQL%E9%9B%86%E7%BE%A4/"/>
    <url>/2025/04/10/MySQL%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结MySQL的集群及相关问题</p>          </div><h1 id="一、MySQL集群架构"><a href="#一、MySQL集群架构" class="headerlink" title="一、MySQL集群架构"></a>一、MySQL集群架构</h1><h2 id="1、架构设计理念"><a href="#1、架构设计理念" class="headerlink" title="1、架构设计理念"></a>1、架构设计理念</h2><p>在集群架构设计时，主要遵从下面<u>三个维度</u>：</p><ol><li>可用性</li><li>扩展性</li><li>一致性</li></ol><h2 id="2、可用性设计"><a href="#2、可用性设计" class="headerlink" title="2、可用性设计"></a>2、可用性设计</h2><ul><li>站点高可用，冗余站点</li><li>服务高可用，冗余服务</li><li>数据高可用，冗余数据</li></ul><p>保证高可用的方法是<strong>冗余</strong>。但是数据冗余带来的问题是数据一致性问题。</p><p>实现高可用的方案有以下几种架构模式：</p><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>简单灵活，能满足多种需求。比较主流的用法，但是写操作高可用需要自行处理。</p><h3 id="双主模式"><a href="#双主模式" class="headerlink" title="双主模式"></a>双主模式</h3><p>互为主从，有双主双写、双主单写两种方式，建议使用双主单写</p><h2 id="3、扩展性设计"><a href="#3、扩展性设计" class="headerlink" title="3、扩展性设计"></a>3、扩展性设计</h2><p>扩展性主要围绕着<u>读操作扩展</u>和<u>写操作扩展</u>展开。</p><blockquote><p>如何扩展以提高读性能？</p></blockquote><ul><li><p><strong>加从库：</strong></p><ul><li>简单易操作，方案成熟。</li><li>从库过多会引发主库性能损耗。建议不要作为长期的扩充方案，应该设法用良好的设计避免持续加从库来缓解读性能问题。</li></ul></li><li><p><strong>分库分表：</strong></p><ul><li>可以分为垂直拆分和水平拆分，垂直拆分可以缓解部分压力，水平拆分理论上可以无限扩展。</li></ul></li></ul><blockquote><p>如何扩展以提高写性能？</p></blockquote><ul><li><strong>分库分表</strong></li></ul><h2 id="4、一致性设计"><a href="#4、一致性设计" class="headerlink" title="4、一致性设计"></a>4、一致性设计</h2><p>一致性主要考虑集群中各数据库数据同步以及同步延迟问题。可以采用的方案如下：</p><ul><li><p>不使用从库</p><ul><li>扩展读性能问题需要单独考虑，否则容易出现系统瓶颈。</li></ul></li><li><p>增加访问路由层</p><ul><li>可以先得到主从同步最长时间 <code>t</code>，在数据发生修改后的 <code>t</code> 时间内，先访问主库。</li></ul></li></ul><h1 id="二、主从模式"><a href="#二、主从模式" class="headerlink" title="二、主从模式"></a>二、主从模式</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>MySQL主从模式是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用<strong>异步复制</strong>方式，这样从节点不用一直访问主服务器来更新自己的数据，从节点可以复制主数据库中的所有数据库，或者特定的数据库，或者特定的表。架构如下：</p><p><img src="/2025/04/10/MySQL%E9%9B%86%E7%BE%A4/image-20250410151511416.png"></p><p>主从复制用途：</p><ul><li>实时灾备，用于故障切换（高可用）</li><li>读写分离，提供查询服务（读扩展）</li><li>数据备份，避免影响业务（高可用）</li></ul><p>主从部署必要条件：</p><ul><li>从库服务器能连通主库</li><li>主库开启binlog日志（设置log-bin参数）</li><li>主从server-id不同</li></ul><h2 id="2、实现原理"><a href="#2、实现原理" class="headerlink" title="2、实现原理"></a>2、实现原理</h2><p>如图：</p><p><img src="/2025/04/10/MySQL%E9%9B%86%E7%BE%A4/image-20250410152720766.png" alt="MySQL主从复制（异步复制）"></p><ol><li>写入Bin log：主库将变更<strong>写入binlog</strong>，提交事务，并更新本地存储数据</li><li><u>binlog dump线程</u>接到写入请求后，读取binlog信息推送给节点的IO线程</li><li>同步Bin log（<u>I&#x2F;O线程</u>）：从库连接到主库后，从库的IO线程负责将主库的binlog日志复制到自己本地，并<strong>写入中继日志中</strong></li><li>回放Bin log（<u>SQL线程</u>）：从库的SQL线程从中继日志中读取binlog，并<strong>执行其中的SQL内容</strong>，即：在从库再次执行一遍</li></ol><p><img src="/2025/04/10/MySQL%E9%9B%86%E7%BE%A4/image-20250410154422407.png" alt="异步复制时序图"></p><p>主从复制存在的问题：</p><ol><li><p>主库宕机后，<strong>数据可能丢失</strong></p></li><li><p>从库只有一个SQL Thread，主库写压力大，<strong>复制可能延时</strong></p></li></ol><h3 id="解决数据丢失问题：半同步复制"><a href="#解决数据丢失问题：半同步复制" class="headerlink" title="解决数据丢失问题：半同步复制"></a>解决数据丢失问题：半同步复制</h3><p>为了提升数据安全，MySQL让Master在某一个时间点等待Slave节点的 ACK（Acknowledgecharacter）消息，接收到ACK消息后才进行事务提交，这也是半同步复制的基础。</p><p>MySQL从5.5版本开始引入了半同步复制机制来降低数据丢失的概率。</p><p>介绍半同步复制之前先快速过一下 MySQL 事务写入碰到主从复制时的完整过程，主库事务写入分为 4个步骤：</p><ol><li>innodb写入redolog文件（prepare阶段）</li><li>binlog文件刷盘、异步处理binlog文件</li><li>innodb提交redolog文件（commit状态）</li><li>主节点发送binlog到从节点</li></ol><ul><li><strong>主从复制：</strong> 主节点不需要关注从节点是否接收到binlog事件</li><li>**半同步复制： **主节点需要在第三步等待从节点返回ACK时，即为after-commit（MySQL 5.5引入）</li><li><strong>增强半同步：</strong> 主节点需要在第二步等待从节点返回ACK时，即为after-sync（MySQL 5.7引入）</li></ul><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/713426.png" alt="半同步复制时序图"></p><h3 id="解决主从延迟问题：并行复制"><a href="#解决主从延迟问题：并行复制" class="headerlink" title="解决主从延迟问题：并行复制"></a>解决主从延迟问题：并行复制</h3><div class="note note-danger">            <p>主从延迟的原因有哪些？</p>          </div><ol><li><strong>主库的从库太多</strong>，主库需要将binlog日志传输给多个从库，导致复制延迟</li><li>在从库执行的SQL中存在<strong>慢查询</strong>语句，导致整体复制进程的延迟</li><li>如果<strong>主库的读写压力过大</strong>，会导致主库处理binlog的速度减慢，进而影响复制延迟</li></ol><div class="note note-danger">            <p>对于主从延迟，可以采取什么措施？</p>          </div><ol><li>减少从库的数量，降低主库的负载，减少复制延迟</li><li>优化慢查询语句，减少从库执行SQL的延迟</li><li>对主库进行性能优化，减少主库的读写压力，提高binlog写入速度</li><li>网络优化：同城部署或同机房部署</li><li>硬件优化：提高cpu、内存、使用ssd硬盘</li><li>并行复制：MySQL5.6提供了基于库的并行复制、5.7基于组提交的并行复制、8.0基于<strong>WRITESET 并行复制</strong></li></ol><p>在从库中有两个线程：IO Thread和SQL Thread，都是<u>单线程</u>模式工作，因此有了<u>延迟问题</u>，我们可以采用<strong>多线程机制</strong>来加强，减少从库复制延迟。（IO Thread多线程意义不大，主要指的是SQL Thread多线程）<br>在MySQL的5.6、5.7、8.0版本上，都是基于上述SQL Thread多线程思想，不断优化，减少复制延迟。</p><h1 id="三、读写分离"><a href="#三、读写分离" class="headerlink" title="三、读写分离"></a>三、读写分离</h1><p>大多数互联网业务中，往往读多写少，这时候数据库的读会首先成为数据库的瓶颈。如果我们已经优化了SQL，但是读依旧还是瓶颈时，这时就可以选择 <strong>“读写分离”</strong> 架构了。</p><p>读写分离首先需要将数据库分为主从库，<u>一个主库用于写数据，多个从库完成读数据的操作，主从库之间通过主从复制机制进行数据的同步</u>：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/642382.png" alt="读写分离"></p><ul><li>在应用中可以在从库追加多个索引来优化查询，主库这些索引可以不加，用于提升写效率</li><li>读写分离架构也能够<u>消除读写锁冲突</u>从而提升数据库的读写性能</li></ul><p>使用读写分离架构需要注意：<strong>主从同步延迟</strong>和<strong>读写分配机制</strong>问题</p><h2 id="1、主从同步延迟"><a href="#1、主从同步延迟" class="headerlink" title="1、主从同步延迟"></a>1、主从同步延迟</h2><p>使用读写分离架构时，数据库主从同步具有延迟性，数据一致性会有影响，对于一些实时性要求比较高的操作，有以下解决方案：</p><ol><li><p>写后立刻读</p><ul><li>在写入数据库后，某个时间段内读操作就去主库，之后读操作访问从库</li></ul></li><li><p>二次查询</p><ul><li>先去从库读取数据，找不到时就去主库进行数据读取</li><li>该操作容易将读压力返还给主库，为了避免恶意攻击，建议对数据库访问API操作进行封装，有利于安全和低耦合</li></ul></li><li><p>根据业务特殊处理</p><ul><li>根据业务特点和重要程度进行调整，比如：<ul><li>重要的、实时性要求高的业务数据读写可以放在主库</li><li>次要的业务，实时性要求不高可以进行读写分离，查询时去从库查询</li></ul></li></ul></li></ol><h2 id="2、读写分离落地"><a href="#2、读写分离落地" class="headerlink" title="2、读写分离落地"></a>2、读写分离落地</h2><p>读写路由分配机制是实现读写分离架构最关键的一个环节，就是<u>控制何时去主库写，何时去从库读</u>。目前较为常见的实现方案分为以下两种：</p><ol><li><p>基于编程和配置实现（应用端）</p><ul><li>程序员在代码中封装数据库的操作，代码中可以根据操作类型进行<strong>路由分配</strong>，<u>增删改时操作主库，查询时操作从库</u>。这类方法也是目前生产环境下应用最广泛的。</li><li>优点：实现简单，因为程序在代码中实现，不需要增加额外的硬件开支</li><li>缺点：需要开发人员来实现，运维人员无从下手，如果其中一个数据库宕机了，就需要修改配置重启项目</li></ul></li><li><p>基于服务器端代理实现（服务器端）</p></li></ol><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/556365.png"></p><p>中间件代理一般<u>介于应用服务器和数据库服务器之间</u>，从图中可以看到，应用服务器并不直接进入到master数据库或者slave数据库，而是进入MySQL proxy代理服务器。代理服务器接收到应用服务器的请求后，先进行判断然后转发到后端master和slave数据库。</p><p>常见的数据库中间件</p><ul><li><p>MySQL Proxy：是官方提供的MySQL中间件产品可以实现负载平衡、读写分离等。</p></li><li><p>MyCat：MyCat是一款基于阿里开源产品Cobar而研发的，基于 Java 语言编写的开源数据库中间件。</p></li><li><p>ShardingSphere：ShardingSphere是一套开源的分布式数据库中间件解决方案，它由ShardingJDBC、Sharding-Proxy和Sharding-Sidecar（计划中）这3款相互独立的产品组成。已经在2020年4月16日从Apache孵化器毕业，成为Apache顶级项目。</p></li><li><p>Atlas：Atlas是由 Qihoo 360公司Web平台部基础架构团队开发维护的一个数据库中间件。</p></li><li><p>Amoeba：变形虫，该开源框架于2008年开始发布一款 Amoeba for MySQL软件。</p></li></ul><blockquote><p>待更。。。。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>集群</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC协议: 为什么要设计RPC协议？如何设计可扩展且向后兼容的协议？</title>
    <link href="/2025/04/10/RPC%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/"/>
    <url>/2025/04/10/RPC%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结RPC框架中协议层的设计</p>          </div><h1 id="为什么要设计RPC协议？"><a href="#为什么要设计RPC协议？" class="headerlink" title="为什么要设计RPC协议？"></a>为什么要设计RPC协议？</h1><p>只有二进制才能在网络中传输，所以 RPC 请求在发送到网络中之前，需要把方法调用的请求参数转成二进制；转成二进制后，写入本地 Socket 中，然后被网卡发送到网络设备中。</p><p>但在传输过程中，RPC 并不会把请求参数的所有二进制数据整体一下子发送到对端机器上，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包（合并的前提是同一个 TCP 连接上的数据）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里涉及到系统参数配置和 TCP 窗口大小的知识，先埋个坑。。。">[1]</span></a></sup>。对于服务提供方应用来说，它会从 TCP 通道里面收到很多的二进制数据，它需要从中识别到二进制数据发送过来的顺序和断句，否则，就会出现常见的TCP传输中的<strong>粘包半包问题</strong>。</p><h2 id="对比HTTP协议"><a href="#对比HTTP协议" class="headerlink" title="对比HTTP协议"></a>对比HTTP协议</h2><p>相对于 HTTP 的用处，RPC 更多的是负责应用间的通信，所以性能要求相对更高。但 HTTP 协议的数据包大小相对请求数据本身，对比可如下面两个方面：</p><ol><li><strong>用途：</strong><ul><li>HTTP：主要用于B&#x2F;S架构，HTTP协议的数据包大小相对请求数据本身要大得多，又需要加入很多无用的内容（如：换行符号、回车符等）</li><li>RPC：主要用于C&#x2F;S架构，对性能要求相对更高，HTTP协议对于RPC来说可能过于臃肿</li></ul></li><li><strong>功能：</strong><ul><li>HTTP协议：属于无状态协议，客户端无法对请求和响应进行关联，每次都需要重新建立连接，响应完成后再关闭连接</li><li>RPC协议：要求更高性能，所以RPC会选择设计更紧凑的私有协议</li></ul></li></ol><h1 id="怎么设计一个私有RPC协议？"><a href="#怎么设计一个私有RPC协议？" class="headerlink" title="怎么设计一个私有RPC协议？"></a>怎么设计一个私有RPC协议？</h1><h2 id="协议里有什么内容？"><a href="#协议里有什么内容？" class="headerlink" title="协议里有什么内容？"></a>协议里有什么内容？</h2><ul><li><p><strong>协议长度：<strong>RPC每次发请求发的大小都是不固定的，所以协议必须能</strong>让接收方正确读出不定长的内容</strong></p><ul><li><p>先固定一个长度（比如4字节）用来保存整个请求数据大小</p></li><li><p>收到数据时，先读取固定长度位置里的值，代表协议体长度</p></li><li><p>再根据值的大小读取协议体的数据，如下：</p></li></ul></li></ul><p><img src="/2025/04/10/RPC%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/image-20250410091841653.png"></p><ul><li>**序列化方式：**服务调用方和提供方都必须知道双方用的序列化方式，这样才能正确进行序列化和反序列化，从而正确读取数据<ul><li>我们需要把<strong>序列化方式</strong>单独拿出来，类似协议长度一样用固定的长度存放</li></ul></li></ul><p>这些需要固定长度存放的参数我们统称为“协议头”，这样整个协议就会拆分成两部分：<strong>协议头和协议体</strong>。</p><p>在协议头里面，除了协议长度、序列化方式之外，还会放一些像协议标示、消息 ID、消息类型这样的参数，而协议体一般只放请求接口方法、请求的业务参数值和一些扩展属性。</p><p>如下图，<strong>协议头是由一堆固定的长度参数组成，而协议体是根据请求接口和参数构造的，长度属于可变的</strong>：</p><p><img src="/2025/04/10/RPC%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/0248526f711996be47ed93ae2ee049da.png" alt="定长协议"></p><h2 id="可扩展协议"><a href="#可扩展协议" class="headerlink" title="可扩展协议"></a>可扩展协议</h2><p>协议设计出来，我们需要考虑其兼容性、可扩展性</p><p>也就是说，我们需要让协议能够容忍我们往协议头里添加新参数，我们思考以下几种场景：</p><h3 id="将扩展参数放到协议头最后"><a href="#将扩展参数放到协议头最后" class="headerlink" title="将扩展参数放到协议头最后"></a>将扩展参数放到协议头最后</h3><p>假设我们的协议头为88bit，其中协议长度占用了32bit，我们为了添加新功能，在协议头里新添加了2bit的新参数，并放到协议头最后。</p><p>假设这时候，服务调用方升级了，但服务提供方没有升级。</p><p>服务调用方会用新的协议发出请求，然而服务提供方接收到请求之后，还是按照原来的协议处理方式处理，即：按照88bit读取协议头，新加入的2bit新参数会被当成协议体的头部，而原协议体的最后2bit会被丢弃，导致<strong>传输数据错误</strong>。</p><h3 id="将扩展参数放到不定长的协议体里面"><a href="#将扩展参数放到不定长的协议体里面" class="headerlink" title="将扩展参数放到不定长的协议体里面"></a>将扩展参数放到不定长的协议体里面</h3><p>协议体里的内容都是需要经过序列化和反序列化处理的，即：如果我们要获取到新参数的值，<u>必须把整个协议体里的数据反序列化出来</u>，这代价太大了。</p><p>比如：</p><ul><li>服务提供方收到一个过期请求，这个过期是说：服务提供方收到的该请求的时间 &gt; 调用方发送的时间和配置的超时时间</li><li>既然已经过期，就没有必要接着处理，直接返回一个超时就好了。</li><li>但要实现这个功能，需要在协议里面传递这个配置的超时时间，如果我们现在把这个超时时间加到协议体里面，就会加重CPU的消耗</li></ul><h3 id="关键：让协议头支持可扩展"><a href="#关键：让协议头支持可扩展" class="headerlink" title="关键：让协议头支持可扩展"></a>关键：让协议头支持可扩展</h3><p>要实现<u>读取不定长的协议头里面的内容</u>，在这之前肯定需要一个固定的地方读取长度，所以我们需要一个<strong>固定的写入协议头的长度</strong></p><p><img src="/2025/04/10/RPC%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/image-20250410094835965.png" alt="可扩展协议"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为解决网络通信中粘包半包的问题，我们一定需要在RPC中添加协议层，并且为了使通信双方的协议设计成可扩展的、向后兼容的，我们需要设计成<u>不定长<strong>协议头</strong>+不定长<strong>协议体</strong></u>的形式。</p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里涉及到系统参数配置和 TCP 窗口大小的知识，先埋个坑。。。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>RPC实战与核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC: 什么是RPC？RPC的通信流程是怎样的？</title>
    <link href="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/"/>
    <url>/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>最近打算开始重新深入学习RPC，这个分类主要是对极客时间的《RPC实战与核心原理》的学习笔记和个人总结</p>          </div><h1 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h1><p>RPC 的全称是 Remote Procedure Call，即<strong>远程过程调用</strong>。</p><ul><li>远程：跨机器而非本机，所以需要用到网络编程才能实现</li><li>RPC：帮助我们<u>屏蔽网络编程细节</u>，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码</li></ul><p><strong>RPC的作用就是体现在以下两个方面：</strong></p><ol><li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li><li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。</li></ol><h1 id="RPC通信流程"><a href="#RPC通信流程" class="headerlink" title="RPC通信流程"></a>RPC通信流程</h1><h2 id="采用TCP协议"><a href="#采用TCP协议" class="headerlink" title="采用TCP协议"></a>采用TCP协议</h2><ul><li>RPC是一个远程调用，需要通过网络来传输数据</li><li>RPC常用于业务系统之间的数据交互，需要保证其可靠性</li></ul><p>综上两点，RPC一般默认采用TCP来传输</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>网络之间通信一定是通过二进制数据进行传输的，但调用方请求的出入参数都是对象</p><p>所以，我们要进行网络之间的数据传输，一定需要把对象提前转换成可传输的二进制，并且要求转换算法是可逆的，即：<strong>序列化</strong></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>服务调用方和提供方之间进行数据传输，会有很多问题，比如粘包和半包问题，这时候我们需要在双方之间制定<strong>协议</strong>，用来标明数据包的类型和长度，从而正确解析数据。</p><p>大多数协议包含：</p><ul><li>数据头：一般用于身份识别<ul><li>协议标识</li><li>数据大小</li><li>请求类型</li><li>序列化类型</li></ul></li><li>消息体：请求的业务参数信息和扩展属性等</li></ul><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体<strong>逆向</strong>还原成请求对象。这个过程叫作<strong>反序列化</strong></p><h2 id="完成方法调用"><a href="#完成方法调用" class="headerlink" title="完成方法调用"></a>完成方法调用</h2><p>服务提供方根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>对于研发人员来说，这样做要掌握太多的 RPC 底层细节，需要手动写代码去构造请求、调用序列化，并进行网络调用，整个 API 非常不友好。</p><p>为了简化 API，屏蔽掉 RPC 细节，即：让使用方只需要关注业务接口，像调用本地一样来调用远程，可以使用<strong>动态代理</strong>技术。</p><p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。</p><p>到这里，一个简单版本的 RPC 框架就实现了。</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/8b14a89aad7a13d32180b43a5fd39945.png"></p><h1 id="RPC-在架构中的位置"><a href="#RPC-在架构中的位置" class="headerlink" title="RPC 在架构中的位置"></a>RPC 在架构中的位置</h1><p><strong>RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。</strong> 利用 RPC 我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。</p><p>RPC 不仅可以用来解决通信问题，它还被用在了很多其他场景，比如：发 MQ、分布式缓存、数据库等。下图是作者之前开发的一个应用架构图：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/f1c131789d1c5cfdecfa8aa51ef56a98.png"></p><p>从上图可以看到，用MQ来处理异步流程、Redis缓存热点数据、MySQL持久化数据，还有在系统中调用另外一个业务系统的接口，这些都是属于 RPC 调用，而 MQ、MySQL 持久化的数据也会存在于一个分布式文件系统中，他们之间的调用也是需要用 RPC 来完成数据交互的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RPC是一个远程过程调用服务，它可以让我们在调用远程服务的方法就像在调用项目内的方法一样，同时，可以隐藏底层网络通信的复杂性，让开发程序员可以更专注于业务逻辑。</p><p>RPC之间的通信包括协议层、序列化层、动态代理层等。另一方面，RPC不仅可以用来解决通信问题，在分布式系统里，MQ、Redis、JDBC之间的业务处理，也会涉及到RPC调用。</p>]]></content>
    
    
    <categories>
      
      <category>RPC实战与核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射机制</title>
    <link href="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结Java中的反射机制</p>          </div><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><strong>作用：</strong><ul><li>通过Java语言中的反射机制，可以<strong>操作字节码文件</strong></li></ul></li><li><strong>应用：</strong><ul><li>编写能够<strong>动态</strong>操纵Java代码的程序</li><li>使用反射，Java可以支持用户界面生成器、对象关系映射器以及很多其他<u>需要动态查询类能力的开发工具</u>。主要作用在<strong>开发工具</strong>时</li></ul></li><li>在 <code>java.lang,reflect,*;</code> 包下</li><li>反射机制相关的重要的类：<ul><li><code>java.lang.Class</code>：整个字节码，代表一个类型（<em>整个类</em>）</li><li><code>java.lang.reflect.Method</code>：字节码中的方法字节码（类中的<em>方法</em>）</li><li><code>java.lang.reflect.Constructor</code>：字节码中的构造方法字节码（类中的<em>构造方法</em>）</li><li><code>java.lang.reflect.Field</code>：字节码中的属性字节码（类中的<em>成员变量（静态变量+实例变量）</em>）<br>  具体如下：</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chen.reflection;    <span class="hljs-comment">/**  </span><span class="hljs-comment"> * java.lang.Class</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> chen  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2025/4/5 19:18  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0  </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;      <span class="hljs-comment">// Field: 成员变量  </span>    <span class="hljs-type">int</span> no;        <span class="hljs-comment">// Constructor: 构造方法  </span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;&#125;      <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;        <span class="hljs-comment">// Method: 方法  </span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;          <span class="hljs-keyword">return</span> no;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;  &#125;</code></pre></div><p>要操作一个类的字节码，要先获取该类的字节码，即该类的 <code>Class</code>。也就是说，要操作 <code>Method</code>、<code>Constructor</code>、<code>Field</code>，需要先获取到 <code>Class</code></p><h1 id="获取Class的三种方式"><a href="#获取Class的三种方式" class="headerlink" title="获取Class的三种方式"></a>获取Class的三种方式</h1><h2 id="1、Class-forName-完整类名"><a href="#1、Class-forName-完整类名" class="headerlink" title="1、Class.forName(&quot;完整类名&quot;);"></a>1、<code>Class.forName(&quot;完整类名&quot;);</code></h2><p>要求：</p><ol><li>静态方法</li><li>方法的参数是一个字符串</li><li>字符串需要的是一个完整类名</li><li>完整类名必须带有包名</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">// c1 代表 String.class 文件，或者说代表 String 类  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);              <span class="hljs-comment">// c2代表 Date 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.util.Date&quot;</span>);              <span class="hljs-comment">// c3 代表 Integer 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Integer&quot;</span>);              <span class="hljs-comment">// c4 代表 System 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.System&quot;</span>);          &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;</code></pre></div><ul><li><code>Class.forName(&quot;完整类名&quot;);</code> - 该方法的执行，会导致<strong>类加载</strong>，类加载时，静态代码块执行：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          Class.forName(<span class="hljs-string">&quot;com.chen.reflection.MyClass&quot;</span>);      &#125;  &#125;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;      <span class="hljs-keyword">static</span> &#123;          System.out.println(<span class="hljs-string">&quot;MyClass 的静态代码块&quot;</span>);      &#125;  &#125;</code></pre></div><ul><li>输出：<br><img src="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/1.png"></li></ul><h2 id="2、对象-getClass"><a href="#2、对象-getClass" class="headerlink" title="2、对象.getClass();"></a>2、<code>对象.getClass();</code></h2><p>Java中任何一个对象都有 <code>getClass()</code> 方法：（Object类中实现的方法）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;          <span class="hljs-keyword">try</span> &#123;              c1 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);          &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;              e.printStackTrace();          &#125;            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;          <span class="hljs-comment">// x 代表 String.class 字节码文件，或者说 代表 String 类型  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.getClass();          <span class="hljs-comment">// c1 和 x 中保存的内存地址是一样的</span>        System.out.println(c1 == x);   <span class="hljs-comment">// true</span>    &#125;  &#125;</code></pre></div><p>底层实现如下：<br><img src="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/2.png"></p><h2 id="3、任何类型-class"><a href="#3、任何类型-class" class="headerlink" title="3、任何类型.class;"></a>3、<code>任何类型.class;</code></h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> String.class;          System.out.println(c);    <span class="hljs-comment">// class java.lang.String  </span>    &#125;  &#125;</code></pre></div><h1 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h1><p><strong>反射机制的灵活性：</strong></p><ul><li>Java代码在不改变源代码的基础上，可以做到不同对象的实例化</li><li>符合开闭原则：对扩展开放，对修改关闭</li></ul><p>如果我们有一个 <code>properties</code> 文件：</p><div class="code-wrapper"><pre><code class="hljs text">className=java.util.Date</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-comment">// 这种方式，只能创建一个User对象，代码写死了  </span>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();            <span class="hljs-comment">/*  </span><span class="hljs-comment">        * 以下方式，创建的对象依赖我们的properties配置文件  </span><span class="hljs-comment">        * */</span>        <span class="hljs-comment">// 通过 IO 流读取 classinfo.properties 文件  </span>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;classinfo.properties&quot;</span>);          <span class="hljs-comment">// 创建属性类对象map  </span>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();          <span class="hljs-comment">// 加载  </span>        pro.load(reader);          <span class="hljs-comment">// 关闭流  </span>        reader.close();            <span class="hljs-comment">// 通过key获取value  </span>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> pro.getProperty(<span class="hljs-string">&quot;className&quot;</span>);          System.out.println(className);            <span class="hljs-comment">// 通过反射机制实例化对象  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(className);          <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> c.newInstance();          System.out.println(o);      &#125;  &#125;</code></pre></div><h1 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-comment">// 获取整个类  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">userClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.entity.User&quot;</span>);          <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> userClass.newInstance();   <span class="hljs-comment">// obj就是User对象，底层调用该对象的无参构造方法  </span>          <span class="hljs-comment">// 获取no属性  </span>        Field noField=  userClass.getDeclaredField(<span class="hljs-string">&quot;no&quot;</span>);            <span class="hljs-comment">// 给obj对象的no属性赋值  </span>        noField.set(obj, <span class="hljs-number">111</span>);          <span class="hljs-comment">// 读取值  </span>        System.out.println(noField.get(obj));   <span class="hljs-comment">// 111  </span>    &#125;  &#125;</code></pre></div><ul><li>反射机制的<strong>缺点</strong>：<strong>打破封装，可以访问到private方法</strong></li></ul><h1 id="调用对象方法"><a href="#调用对象方法" class="headerlink" title="调用对象方法"></a><strong>调用对象方法</strong></h1><p>有个 <code>UserService</code> 类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chen.reflection.service;    <span class="hljs-comment">/**  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> chen  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2025/4/7 19:50  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0  </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String name, String password)</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="hljs-string">&quot;123&quot;</span>.equals(password)) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span> &#123;          System.out.println(<span class="hljs-string">&quot;已退出&quot;</span>);      &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">userServiceClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.service.UserService&quot;</span>);          <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> userServiceClass.newInstance();          <span class="hljs-type">Method</span> <span class="hljs-variable">loginMethod</span> <span class="hljs-operator">=</span> userServiceClass.getDeclaredMethod(<span class="hljs-string">&quot;login&quot;</span>, String.class, String.class);          <span class="hljs-comment">// 返回值  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> loginMethod.invoke(obj, <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);          System.out.println(returnValue);      &#125;  &#125;</code></pre></div><h1 id="调用构造方法实例化对象"><a href="#调用构造方法实例化对象" class="headerlink" title="调用构造方法实例化对象"></a>调用构造方法实例化对象</h1><p>现在有一个 <code>User</code> 类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;      <span class="hljs-comment">// Field  </span>    <span class="hljs-type">int</span> no;      String name;      <span class="hljs-type">int</span> age;      <span class="hljs-type">boolean</span> sex;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, <span class="hljs-type">int</span> age)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;          <span class="hljs-built_in">this</span>.age = age;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, <span class="hljs-type">int</span> age, <span class="hljs-type">boolean</span> sex)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;          <span class="hljs-built_in">this</span>.age = age;          <span class="hljs-built_in">this</span>.sex = sex;      &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.entity.User&quot;</span>);          <span class="hljs-comment">// 调用无参构造方法  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> c.newInstance();          System.out.println(obj);            <span class="hljs-comment">// 调用有参构造方法  </span>        <span class="hljs-comment">// 1、获取到这个有参数的构造方法  </span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(<span class="hljs-type">int</span>.class, String.class);          <span class="hljs-comment">// 2、调用构造方法new对象  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">newObj</span> <span class="hljs-operator">=</span> con.newInstance(<span class="hljs-number">110</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);          System.out.println(newObj);            <span class="hljs-comment">// 获取无参构造方法  </span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con2</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();          <span class="hljs-type">Object</span> <span class="hljs-variable">newObj2</span> <span class="hljs-operator">=</span> con2.newInstance();          System.out.println(newObj2);      &#125;  &#125;</code></pre></div><h1 id="获取父类和父接口"><a href="#获取父类和父接口" class="headerlink" title="获取父类和父接口"></a>获取父类和父接口</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">stringClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);            <span class="hljs-comment">// 获取String的父类  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> stringClass.getSuperclass();          System.out.println(superClass.getName());            System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);            <span class="hljs-comment">// 获取String类实现的所有接口  </span>        Class[] interfaces = stringClass.getInterfaces();          <span class="hljs-keyword">for</span> (Class in : interfaces) &#123;              System.out.println(in.getName());          &#125;      &#125;  &#125;</code></pre></div><p><img src="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/3.png"></p><h1 id="反射的弊端"><a href="#反射的弊端" class="headerlink" title="反射的弊端"></a>反射的弊端</h1><ol><li>反射很慢<ul><li>慢的原因：反射调用需要找到目标方法，而找目标方法是通过遍历当前类甚至是父类的方法来找，并且调用，这个时间复杂度<code>O(n)</code></li><li>如何解决：可以将目标方法缓存起来，下次直接调用而并非先找到目标方法再调用</li></ul></li><li>使用反射会有安全性的问题<ul><li>反射打破了封装，可以访问到private方法，可能有让黑客有窃取信息的漏洞</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL日志</title>
    <link href="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/"/>
    <url>/2025/04/07/MySQL%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结MySQL中的三大日志（redo log、undo log、binlog）</p>          </div><h1 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a>一、分类</h1><ol><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>归档日志（bin log）</li><li>错误日志（error log）</li><li>慢查询日志（slow query log）</li><li>一般查询日志（general log）</li><li>中继日志（relay log）</li></ol><h1 id="二、redo-log"><a href="#二、redo-log" class="headerlink" title="二、redo log"></a>二、redo log</h1><p>重做日志，<strong>InnoDB存储引擎独有</strong>的日志，主要作用：让MySQL拥有<strong>崩溃恢复</strong>的能力</p><ul><li>MySQL实例挂了或宕机了，重启后，InnoDB存储引擎会使用redo log恢复数据</li></ul><h2 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h2><ol><li>物理日志<ul><li>记录的是<strong>在某个数据页做了什么修改</strong></li></ul></li><li>保证数据的持久性<ul><li>redo log会在<strong>事务提交时</strong>将日志存储到磁盘 <code>Redo Log File</code> ，保证<strong>日志的持久性</strong></li><li>同时MySQL会将数据写入磁盘，保证<strong>数据的持久性</strong></li></ul></li></ol><h2 id="2、组成"><a href="#2、组成" class="headerlink" title="2、组成"></a>2、组成</h2><ol><li><p>Redo Log Buffer：内存中的重做日志<strong>缓存</strong></p></li><li><p>Redo Log File：重做日志<strong>文件</strong></p></li></ol><p>MySQL中数据是以<strong>页</strong>为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到Buffer Pool中。后续的查询都是先从Buffer Pool中找，没有命中再去硬盘加载，<strong>减少硬盘IO开销，提升性能。</strong></p><p>更新表数据的时候，也是如此，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新。然后会把在某个数据页上做了什么修改记录到重做日志缓存（Redo Log Buffer）里，接着刷盘到Redo Log文件里。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面。</p><ul><li>流程如下：</li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407162420090.png"></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><strong>固定大小</strong>，循环写入</p><ul><li>配置为一组4个文件，每个文件1GB大小</li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164547681.png"></p><ul><li><strong>注意这里有一个<code>check point</code>，如果发生异常，redolog就是根据checkpoint来感知到，数据要恢复到哪里的</strong></li></ul><h3 id="WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘"><a href="#WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘" class="headerlink" title="WAL(Write-Ahead Logging)技术：先写日志、再写磁盘"></a>WAL(Write-Ahead Logging)技术：先写日志、再写磁盘</h3><div class="note note-danger">            <p>为什么要在写磁盘前先写日志？直接写磁盘不可以吗？</p>          </div><ul><li><p>性能问题：</p><ol><li><strong>redolog结构简单：</strong><ul><li>InnoDB在磁盘中存储的基本单元是页，可能本次修改只变更一页中几个字节，但是需要刷新整页的数据，<strong>浪费资源</strong></li><li>redolog记录的是物理层面上的数据修改，因此redolog也叫物理日志。这些修改记录包含了数据页的物理地址（Page Number）和修改的具体内容（在某个数据页做了什么修改）</li><li>正是因为redolog中记录的数据结构简单，只记录一些物理地址以及变更状态等信息，因此数据先写入redolog要比直接写入到表快多了</li><li>Redo Log作为“临时存储的数据区域”，当Redo Buffer中的数据已经到达一定大小后，Redo Buffer也会将这部分数据写入到Redo Log中，此时数据还未提交，但是已经写入到磁盘中了。</li></ul></li></ol><p>  <img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250408183748948.png" alt="InnoDB数据页和RedoLog日志格式"></p><ol start="2"><li><strong>顺序IO性能远高于随机IO：</strong><ul><li>数据在MySQL中存储是以页为单位的，一个事务可能修改了多页中的数据，页之间又是不连续的，如果直接写入到磁盘中对应的页中，就会产生<strong>随机IO，性能更差</strong></li><li>redolog是通过往redolog日志中追加数据的方式，属于<strong>顺序IO</strong>，效率高。这样可能会影响Redo Log恢复数据时的性能，但可以保证在提交时期能够快速写入Redo Log日志记录本次事务的更改。</li></ul></li></ol></li></ul><h2 id="3、刷盘时机"><a href="#3、刷盘时机" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>InnoDB存储引擎为Redo Log的刷盘策略提供了 <code>innodb-f1ush_log-at_-trX-commit</code> 参数，它支持三种策略：</p><h3 id="（1）0-延时写"><a href="#（1）0-延时写" class="headerlink" title="（1）0 延时写"></a>（1）0 延时写</h3><p>每次事务提交时都只是把redo log留在redo log buffer中，开启一个后台线程，<strong>每1s刷新一次到磁盘中</strong>：</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407163806765.png"></p><ul><li>风险：如果数据库宕机了，可能会丢失1秒内的数据</li></ul><h3 id="（2）1-实时写、实时刷"><a href="#（2）1-实时写、实时刷" class="headerlink" title="（2）1 实时写、实时刷"></a>（2）1 实时写、实时刷</h3><p>每次<strong>事务提交时</strong>都将redo log直接持久化到磁盘，<strong>真正保证数据的持久性</strong>（<strong>默认值</strong>)</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164032208.png"></p><ul><li>只要事务提交成功，redo log记录就一定在硬盘里，<strong>不会有任何数据丢失</strong></li><li>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</li></ul><h3 id="（3）2-实时写、延时刷"><a href="#（3）2-实时写、延时刷" class="headerlink" title="（3）2 实时写、延时刷"></a>（3）2 实时写、延时刷</h3><p>每次事务提交时都只是把 redo log 写到 page cache，每秒刷一次到磁盘（速度快，但是会丢1s的数据，甚至更多，1s并不严格）</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164428343.png"></p><h1 id="三、undo-log"><a href="#三、undo-log" class="headerlink" title="三、undo log"></a>三、undo log</h1><p><strong>回滚日志</strong>，redo log一旦提交意味着持久化了，但有时候需要对其进行回滚操作，那就需要undo log</p><h2 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h2><ul><li>逻辑日志，可以理解为存储的是sql：<ul><li>在事务中使用的每一条 INSERT 都对应了一条 DELETE</li><li>每一条 UPDATE 都对应一条相反的 UPDATE 语句</li></ul></li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407165157198.png"></p><ul><li>保证事务的<strong>一致性</strong></li></ul><p>详见：MVCC机制</p><h1 id="四、binlog"><a href="#四、binlog" class="headerlink" title="四、binlog"></a>四、binlog</h1><p>归档日志，MySQL的<strong>Server层</strong>实现的日志，所有引擎都可以使用，主要作用：备份恢复、灾难恢复、主从复制</p><h2 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h2><ul><li>逻辑日志，记录语句的原始逻辑</li><li><strong>追加</strong>写入，写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</li></ul><div class="note note-danger">            <p>既然有了redolog，为什么还要有binlog？</p>          </div><p>给出两个日志的对比：</p><table><thead><tr><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>InnoDB 引擎特有的</td><td>MySQL的<strong>Server层</strong>实现的，<br /><strong>所有引擎</strong>都可以使用</td></tr><tr><td><strong>物理</strong>日志，<br />记录“在某个数据页上做了什么修改”</td><td><strong>逻辑</strong>日志，<br />记录这个语句的原始逻辑（“给ID&#x3D;2这一行的c字段加1”）</td></tr><tr><td><strong>循环</strong>写，空间固定会用完</td><td><strong>追加</strong>写入，<br />写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</td></tr></tbody></table><ol><li><p><strong>历史原因：</strong></p><ul><li><p>最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="保证即使数据库发生异常重启，之前提交的记录都不会丢失的能力，我们称为**crash-safe**">[1]</span></a></sup> 的能力，binlog 日志只能用于<strong>归档</strong></p></li><li><p>InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力</p></li></ul></li><li><p><strong>用途方面：</strong></p><ul><li>正是因为binlog日志<strong>不会覆盖以前的日志</strong>的特点，如果不小心把<strong>整个数据库的数据</strong>删除了，只能使用binlog文件进行恢复，因为redolog日志的空间是固定的，会覆盖掉之前的日志。<ul><li>即：<strong>binlog用于灾难恢复的场景，而redolog只能恢复较近的数据。</strong></li></ul></li></ul></li></ol><h2 id="2、组成-1"><a href="#2、组成-1" class="headerlink" title="2、组成"></a>2、组成</h2><p>binlog有三种格式</p><h3 id="（1）Statement"><a href="#（1）Statement" class="headerlink" title="（1）Statement"></a>（1）Statement</h3><ul><li>记录<strong>SQL语句的原文</strong></li></ul><p>会出现的问题：对于一些时间函数（比如<code>now()</code>）会导致主从同步的数据前后不一致</p><h3 id="（2）Row"><a href="#（2）Row" class="headerlink" title="（2）Row"></a>（2）Row</h3><ul><li>记录<strong>数据的具体变化</strong><ul><li>insert：新插入的行的所有字段列的值</li><li>update：行更新前后的所有字段列的值</li><li>delete：行删除前的所有字段列的值</li></ul></li></ul><p>数据更安全，但同时，文件也更大</p><h3 id="（3）Mixed"><a href="#（3）Mixed" class="headerlink" title="（3）Mixed"></a>（3）Mixed</h3><p>由MySQL自主选择以上的两种格式</p><p>默认使用Statement，遇到可能导致主从不一致的SQL语句时，改用Row</p><h2 id="3、刷盘时机-1"><a href="#3、刷盘时机-1" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>和redolog一样，都是WAL日志，刷盘时机由 <code>sync_binlog</code> 配置参数指定</p><ul><li><p>0（延迟写）：每次提交事务都不会刷盘，由系统自己决定什么时候刷盘，可能会丢失数据。</p></li><li><p>1（实时写）：每次提交事务，都会刷盘，性能较差。</p></li><li><p>N（延迟写）：提交N个事务后，才会刷盘。</p></li></ul><p>接下来可以完善一下上面的redolog提交事务的图：</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407183824785.png"></p><h3 id="关于两阶段提交"><a href="#关于两阶段提交" class="headerlink" title="关于两阶段提交"></a>关于两阶段提交</h3><div class="note note-danger">            <p>为什么需要两阶段提交？</p>          </div><ul><li><p>为了解决两个日志之间<strong>逻辑一致</strong>的问题。</p><ul><li>如果redolog写完之后，binlog写入时发生了异常，导致binlog和redolog之间的逻辑不一致</li><li>如果采用两阶段提交，就可以感知到写入binlog时发生了异常，后续再进行回滚或是别的补偿操作即可<ul><li>写入binlog时如果发生了异常，MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应bin log日志，就会回滚该事务</li></ul></li></ul></li><li><p>如果是redolog commit阶段发生了异常，则不会回滚事务，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的bin log日志，所以MySQL认为是完整的，就会提交事务恢复数据</p></li></ul><h3 id="系统崩溃后重启如何刷新数据？"><a href="#系统崩溃后重启如何刷新数据？" class="headerlink" title="系统崩溃后重启如何刷新数据？"></a>系统崩溃后重启如何刷新数据？</h3><ul><li>写入undo log之前崩溃：这时undo log和bin log中都没有数据，此时满足数据一致性不需要进行操作</li><li>写入bin log之前崩溃：此时根据undo log中的事务id去bin log中查找是没有数据的，因此会回滚</li><li>写入bin log之后崩溃：无论redo log有没有修改为commit状态，都会把数据更新到磁盘</li></ul><p>这种机制确保了在MySQL主从复制架构中，即使在某个阶段MySQL宕机，也可以在恢复时根据redo log和binlog的状态来决定是否提交或回滚事务，从而保证了主从机的数据一致性。</p><h2 id="4、主从复制"><a href="#4、主从复制" class="headerlink" title="4、主从复制"></a>4、主从复制</h2><p>MySQL的主从复制依赖于bin log，也就是<strong>记录MySQL上的所有变化</strong>并<strong>以二进制形式保存在磁盘</strong>上。</p><p>详见：<a href="https://feiyeee.github.io/2025/04/10/MySQL%E9%9B%86%E7%BE%A4/#%E4%BA%8C%E3%80%81%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F">MySQL集群：主从模式</a></p><hr><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>保证即使数据库发生异常重启，之前提交的记录都不会丢失的能力，我们称为<strong>crash-safe</strong><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Zset</title>
    <link href="/2025/04/07/Redis-Zset/"/>
    <url>/2025/04/07/Redis-Zset/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍 Redis Zset 的底层数据结构实现即原理。</p></blockquote><p>zset底层在数据少的时候是压缩列表，数据量多了会进化成跳表。</p><h1 id="什么时候用压缩列表，什么时候用跳表？"><a href="#什么时候用压缩列表，什么时候用跳表？" class="headerlink" title="什么时候用压缩列表，什么时候用跳表？"></a>什么时候用压缩列表，什么时候用跳表？</h1><p>压缩列表使用要求：</p><ul><li>有序集合保存的元素<strong>数量小于128个</strong></li><li>有序集合保存的所有元素<strong>长度小于64字节</strong><br>  如果不满足以上两个条件之一，则进化成跳表</li></ul><h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表底层就是<strong>有序数组 + 标识符</strong>，标识符包括：列表长度、尾部偏移量、列表元素个数、列表结束标识符：</p><ul><li><strong>列表长度</strong>：保存整个压缩列表占用的内存字节数</li><li><strong>尾部偏移量</strong>：保存压缩列表起始地址到最后一个节点的字节数，可以快速定位到最后一个节点</li><li><strong>列表元素个数</strong>：保存压缩列表的节点个数</li><li><strong>列表结束标识符</strong>：特殊值0xFF（十进制为255），表示压缩列表的结束</li></ul><p>压缩列表结构：<br><img src="/2025/04/07/Redis-Zset/1.png"></p><ul><li>如果查找定位第一个元素和最后一个元素：时间复杂度为 <code>O(1)</code> - 通过表头三个字段直接定位</li><li>查找其他元素只能逐个查找：时间复杂度为 <code>O(n)</code></li></ul><h1 id="为什么用跳表？"><a href="#为什么用跳表？" class="headerlink" title="为什么用跳表？"></a>为什么用跳表？</h1><p>跳表是在<strong>有序链表</strong>的基础上进化而来的，它结合了：</p><ol><li><p><strong>链表</strong>在内存空间中不需要一块连续的区域</p></li><li><p><strong>有序数组</strong>的高效的查找算法：二分查找</p></li></ol><p>  两个优点。具体来说，<em>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现了数据的快速定位。</em> 如下：<br>  <img src="/2025/04/07/Redis-Zset/NeatReader-1743990195139.png" alt="NeatReader-1743990195139"></p><ul><li>跳表在链表的基础上增加了多级索引以提升查找的效率，其实是一个<strong>空间换时间</strong>的方案，必然会带来一个问题：索引是占内存的</li><li>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略</li></ul><h1 id="跳表的具体实现"><a href="#跳表的具体实现" class="headerlink" title="跳表的具体实现"></a>跳表的具体实现</h1><h2 id="1、普通的有序单向链表"><a href="#1、普通的有序单向链表" class="headerlink" title="1、普通的有序单向链表"></a>1、普通的有序单向链表</h2><p><img src="/2025/04/07/Redis-Zset/20250407094915.png"></p><p>如果我们需要查找节点33，需要从头节点开始一个个遍历，遍历6次，时间复杂度为 <code>O(n)</code></p><h2 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h2><p>我们在以上的有序单向链表的上一层，再添加一个一级索引：<br><img src="/2025/04/07/Redis-Zset/20250407095240.png" alt="Pasted image 20250407095240"></p><ul><li>查找节点33，遍历顺序为：<code>1 -&gt; 11 -&gt; 27 -&gt; 33</code>，一共遍历4次</li></ul><p>如果再向上添加一级索引：<br><img src="/2025/04/07/Redis-Zset/20250407095612.png"></p><ul><li>查找节点33，遍历顺序为：<code>1 -&gt; 27 -&gt; 33</code>，只需要遍历3次</li></ul><h1 id="索引建立时机"><a href="#索引建立时机" class="headerlink" title="索引建立时机"></a>索引建立时机</h1><p>前面提到，跳表的实现还是<strong>基于有序数组的二分查找</strong>来实现的，具体如下：<br>我们在新加一个节点的时候，可以考虑一下，现在最多有几层索引，如果现在一层都没有，上来就建了8层，就很没有必要，索引新加一个节点最好最多再往上建立一层索引，那么具体多少层，可以这么想，在第一层建立的概率是1&#x2F;2，第二层建立的概率是1&#x2F;4，第三层建立的概率是1&#x2F;8……</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (level &lt; maxLevel &amp;&amp; Math.random() &gt; <span class="hljs-number">0.5</span>) &#123;        level++;    &#125;    <span class="hljs-keyword">return</span> level;&#125;</code></pre></div><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;      <span class="hljs-comment">// 随机因子，这里设置成0.5</span>    <span class="hljs-type">double</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5d</span>;        <span class="hljs-comment">// 最大层级  </span>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;        <span class="hljs-comment">// 当前最大层级  </span>    <span class="hljs-type">int</span> <span class="hljs-variable">currentMaxLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(maxLevel, -<span class="hljs-number">1</span>);        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;          <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;          <span class="hljs-comment">// 从最大层开始查找，找到前一节点，通过--i，移动到下层再开始查找  </span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;              <span class="hljs-keyword">while</span> (p.nextNodes[i] != <span class="hljs-literal">null</span> &amp;&amp; p.nextNodes[i].value &lt; value) &#123;                  <span class="hljs-comment">// 找到前一节点  </span>                p = p.nextNodes[i];              &#125;          &#125;            <span class="hljs-keyword">if</span> (p.nextNodes[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span> &amp;&amp; p.nextNodes[<span class="hljs-number">0</span>].value == value) &#123;              <span class="hljs-keyword">return</span> p.nextNodes[<span class="hljs-number">0</span>];          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;          <span class="hljs-comment">// level代表这个节点存在于几层链表中  </span>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> randomLevel();          <span class="hljs-keyword">if</span> (level &gt; currentMaxLevel) &#123;              level = ++currentMaxLevel;          &#125;          <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(level, value);          <span class="hljs-type">Node</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> head;          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> currentMaxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;              <span class="hljs-comment">// 如果当前节点当前层级的下一个节点不为空，且比下一个节点的值小  往下走  </span>            <span class="hljs-keyword">while</span> (point.nextNodes[i] != <span class="hljs-literal">null</span> &amp;&amp; point.nextNodes[i].value &lt; value) &#123;                  point = point.nextNodes[i];              &#125;              <span class="hljs-comment">// 节点层级比当前层级大，在该层级插入该节点   之后继续遍历  </span>            <span class="hljs-keyword">if</span> (level &gt; i) &#123;                  <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> point.nextNodes[i];                  point.nextNodes[i] = newNode;                  newNode.nextNodes[i] = temp;              &#125;          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;        <span class="hljs-comment">// 随机层级，如果生成的概率&gt;0.5，就level++  </span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;          <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;          <span class="hljs-keyword">while</span> (level &lt; maxLevel &amp;&amp; Math.random() &gt; factor) &#123;              level++;          &#125;          <span class="hljs-keyword">return</span> level;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAll</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;          <span class="hljs-keyword">if</span> (level &gt; currentMaxLevel) &#123;              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;还没有到这个层数&quot;</span>);          &#125;          <span class="hljs-type">Node</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> head;          <span class="hljs-keyword">while</span> (point.nextNodes[level - <span class="hljs-number">1</span>] != <span class="hljs-literal">null</span>) &#123;              System.out.print(point.nextNodes[level - <span class="hljs-number">1</span>] + <span class="hljs-string">&quot; &quot;</span>);              point = point.nextNodes[level - <span class="hljs-number">1</span>];          &#125;          System.out.println();      &#125;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;          <span class="hljs-comment">// 节点值  </span>        <span class="hljs-type">int</span> value;            <span class="hljs-comment">/**  </span><span class="hljs-comment">         * 这个节点在某一层的下一个节点的集合，比如nextNodes[2]就是node在第二层的下一个节点  </span><span class="hljs-comment">         */</span>          Node[] nextNodes;            <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">int</span> value)</span> &#123;              nextNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[level];              <span class="hljs-built_in">this</span>.value = value;          &#125;            <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +                      <span class="hljs-string">&quot;value=&quot;</span> + value +                      <span class="hljs-string">&#x27;&#125;&#x27;</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">SkipList</span> <span class="hljs-variable">skipList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipList</span>();          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;              skipList.insert(i);          &#125;          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> skipList.currentMaxLevel; i &gt; <span class="hljs-number">0</span>; i--) &#123;              skipList.printAll(i);          &#125;      &#125;  &#125;</code></pre></div><h1 id="为什么不使用红黑树？"><a href="#为什么不使用红黑树？" class="headerlink" title="为什么不使用红黑树？"></a>为什么不使用红黑树？</h1><ol><li>虽然跳表消耗较多的内存，但是我们内部优化过跳表，可以接受。</li><li>跳表的实现很简单，至少比红黑树简单的多。</li><li>多范围查询的支持，跳表完胜红黑树。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
