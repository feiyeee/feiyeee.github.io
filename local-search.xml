<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RPC协议: 为什么要设计RPC协议？如何设计可扩展且向后兼容的协议？</title>
    <link href="/2025/04/10/RPC%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/"/>
    <url>/2025/04/10/RPC%E5%8D%8F%E8%AE%AE-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结RPC框架中协议层的设计</p>          </div><h1 id="为什么要设计RPC协议？"><a href="#为什么要设计RPC协议？" class="headerlink" title="为什么要设计RPC协议？"></a>为什么要设计RPC协议？</h1><p>只有二进制才能在网络中传输，所以 RPC 请求在发送到网络中之前，需要把方法调用的请求参数转成二进制；转成二进制后，写入本地 Socket 中，然后被网卡发送到网络设备中。</p><p>但在传输过程中，RPC 并不会把请求参数的所有二进制数据整体一下子发送到对端机器上，中间可能会拆分成好几个数据包，也可能会合并其他请求的数据包（合并的前提是同一个 TCP 连接上的数据）<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="这里涉及到系统参数配置和 TCP 窗口大小的知识，先埋个坑。。。">[1]</span></a></sup>。对于服务提供方应用来说，它会从 TCP 通道里面收到很多的二进制数据，它需要从中识别到二进制数据发送过来的顺序和断句，否则，就会出现常见的TCP传输中的<strong>粘包半包问题</strong>。</p><h2 id="对比HTTP协议"><a href="#对比HTTP协议" class="headerlink" title="对比HTTP协议"></a>对比HTTP协议</h2><p>这还要从 RPC 的作用说起，相对于 HTTP 的用处，RPC 更多的是负责应用间的通信，所以性能要求相对更高。但 HTTP 协议的数据包大小相对请求数据本身</p><ol><li><strong>用途：</strong><ul><li>HTTP：主要用于B&#x2F;S架构，HTTP协议的数据包大小相对请求数据本身要大得多，又需要加入很多无用的内容（如：换行符号、回车符等）</li><li>RPC：主要用于C&#x2F;S架构，对性能要求相对更高，HTTP协议对于RPC来说可能过于臃肿</li></ul></li><li><strong>功能：</strong><ul><li>HTTP协议：属于无状态协议，客户端无法对请求和响应进行关联，每次都需要重新建立连接，响应完成后再关闭连接</li><li>RPC协议：要求更高性能，所以RPC会选择设计更紧凑的私有协议</li></ul></li></ol><h1 id="怎么设计一个私有RPC协议？"><a href="#怎么设计一个私有RPC协议？" class="headerlink" title="怎么设计一个私有RPC协议？"></a>怎么设计一个私有RPC协议？</h1><h2 id="协议里有什么内容？"><a href="#协议里有什么内容？" class="headerlink" title="协议里有什么内容？"></a>协议里有什么内容？</h2><ul><li><p><strong>协议长度：<strong>RPC每次发请求发的大小都是不固定的，所以协议必须能</strong>让接收方正确读出不定长的内容</strong></p><ul><li><p>先固定一个长度（比如4字节）用来保存整个请求数据大小</p></li><li><p>收到数据时，先读取固定长度位置里的值，代表协议体长度</p></li><li><p>再根据值的大小读取协议体的数据，如下：</p></li></ul></li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/image-20250410091841653.png"></p><ul><li>**序列化方式：**服务调用方和提供方都必须知道双方用的序列化方式，这样才能正确进行序列化和反序列化，从而正确读取数据<ul><li>我们需要把<strong>序列化方式</strong>单独拿出来，类似协议长度一样用固定的长度存放</li></ul></li></ul><p>这些需要固定长度存放的参数我们统称为“协议头”，这样整个协议就会拆分成两部分：<strong>协议头和协议体</strong>。</p><p>在协议头里面，除了协议长度、序列化方式之外，还会放一些像协议标示、消息 ID、消息类型这样的参数，而协议体一般只放请求接口方法、请求的业务参数值和一些扩展属性。</p><p>如下图，<strong>协议头是由一堆固定的长度参数组成，而协议体是根据请求接口和参数构造的，长度属于可变的</strong>：</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/0248526f711996be47ed93ae2ee049da.png" alt="定长协议"></p><h2 id="可扩展协议"><a href="#可扩展协议" class="headerlink" title="可扩展协议"></a>可扩展协议</h2><p>协议设计出来，我们需要考虑其兼容性、可扩展性</p><p>也就是说，我们需要让协议能够容忍我们往协议头里添加新参数，我们思考以下几种场景：</p><h3 id="将扩展参数放到协议头最后"><a href="#将扩展参数放到协议头最后" class="headerlink" title="将扩展参数放到协议头最后"></a>将扩展参数放到协议头最后</h3><p>假设我们的协议头为88bit，其中协议长度占用了32bit，我们为了添加新功能，在协议头里新添加了2bit的新参数，并放到协议头最后。</p><p>假设这时候，服务调用方升级了，但服务提供方没有升级。</p><p>服务调用方会用新的协议发出请求，然而服务提供方接收到请求之后，还是按照原来的协议处理方式处理，即：按照88bit读取协议头，新加入的2bit新参数会被当成协议体的头部，而原协议体的最后2bit会被丢弃，导致<strong>传输数据错误</strong>。</p><h3 id="将扩展参数放到不定长的协议体里面"><a href="#将扩展参数放到不定长的协议体里面" class="headerlink" title="将扩展参数放到不定长的协议体里面"></a>将扩展参数放到不定长的协议体里面</h3><p>协议体里的内容都是需要经过序列化和反序列化处理的，即：如果我们要获取到新参数的值，<u>必须把整个协议体里的数据反序列化出来</u>，这代价太大了。</p><p>比如：</p><ul><li>服务提供方收到一个过期请求，这个过期是说：服务提供方收到的该请求的时间 &gt; 调用方发送的时间和配置的超时时间</li><li>既然已经过期，就没有必要接着处理，直接返回一个超时就好了。</li><li>但要实现这个功能，需要在协议里面传递这个配置的超时时间，如果我们现在把这个超时时间加到协议体里面，就会加重CPU的消耗</li></ul><h3 id="关键：让协议头支持可扩展"><a href="#关键：让协议头支持可扩展" class="headerlink" title="关键：让协议头支持可扩展"></a>关键：让协议头支持可扩展</h3><p>要实现<u>读取不定长的协议头里面的内容</u>，在这之前肯定需要一个固定的地方读取长度，所以我们需要一个<strong>固定的写入协议头的长度</strong></p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E6%89%A9%E5%B1%95%E4%B8%94%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F/image-20250410094835965.png" alt="可扩展协议"></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里涉及到系统参数配置和 TCP 窗口大小的知识，先埋个坑。。。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>RPC实战与核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC: 什么是RPC？RPC的通信流程是怎样的？</title>
    <link href="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/"/>
    <url>/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>最近打算开始重新深入学习RPC，这个分类主要是对极客时间的《RPC实战与核心原理》的学习笔记和个人总结</p>          </div><h1 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h1><p>RPC 的全称是 Remote Procedure Call，即<strong>远程过程调用</strong>。</p><ul><li>远程：跨机器而非本机，所以需要用到网络编程才能实现</li><li>RPC：帮助我们<u>屏蔽网络编程细节</u>，实现调用远程方法就跟调用本地（同一个项目中的方法）一样的体验，我们不需要因为这个方法是远程调用就需要编写很多与业务无关的代码</li></ul><p><strong>RPC的作用就是体现在以下两个方面：</strong></p><ol><li>屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法；</li><li>隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。</li></ol><h1 id="RPC通信流程"><a href="#RPC通信流程" class="headerlink" title="RPC通信流程"></a>RPC通信流程</h1><h2 id="采用TCP协议"><a href="#采用TCP协议" class="headerlink" title="采用TCP协议"></a>采用TCP协议</h2><ul><li>RPC是一个远程调用，需要通过网络来传输数据</li><li>RPC常用于业务系统之间的数据交互，需要保证其可靠性</li></ul><p>综上两点，RPC一般默认采用TCP来传输</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>网络之间通信一定是通过二进制数据进行传输的，但调用方请求的出入参数都是对象</p><p>所以，我们要进行网络之间的数据传输，一定需要把对象提前转换成可传输的二进制，并且要求转换算法是可逆的，即：<strong>序列化</strong></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>服务调用方和提供方之间进行数据传输，会有很多问题，比如粘包和半包问题，这时候我们需要在双方之间制定<strong>协议</strong>，用来标明数据包的类型和长度，从而正确解析数据。</p><p>大多数协议包含：</p><ul><li>数据头：一般用于身份识别<ul><li>协议标识</li><li>数据大小</li><li>请求类型</li><li>序列化类型</li></ul></li><li>消息体：请求的业务参数信息和扩展属性等</li></ul><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>根据协议格式，服务提供方就可以正确地从二进制数据中分割出不同的请求来，同时根据请求类型和序列化类型，把二进制的消息体<strong>逆向</strong>还原成请求对象。这个过程叫作<strong>反序列化</strong></p><h2 id="完成方法调用"><a href="#完成方法调用" class="headerlink" title="完成方法调用"></a>完成方法调用</h2><p>服务提供方根据反序列化出来的请求对象找到对应的实现类，完成真正的方法调用，然后把执行结果序列化后，回写到对应的 TCP 通道里面。调用方获取到应答的数据包后，再反序列化成应答对象，这样调用方就完成了一次 RPC 调用。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>对于研发人员来说，这样做要掌握太多的 RPC 底层细节，需要手动写代码去构造请求、调用序列化，并进行网络调用，整个 API 非常不友好。</p><p>为了简化 API，屏蔽掉 RPC 细节，即：让使用方只需要关注业务接口，像调用本地一样来调用远程，可以使用<strong>动态代理</strong>技术。</p><p>由服务提供者给出业务接口声明，在调用方的程序里面，RPC 框架根据调用的服务接口提前生成动态代理实现类，并通过依赖注入等技术注入到声明了该接口的相关业务逻辑里面。该代理实现类会拦截所有的方法调用，在提供的方法处理逻辑里面完成一整套的远程调用，并把远程调用结果返回给调用方，这样调用方在调用远程方法的时候就获得了像调用本地接口一样的体验。</p><p>到这里，一个简单版本的 RPC 框架就实现了。</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/8b14a89aad7a13d32180b43a5fd39945.png"></p><h1 id="RPC-在架构中的位置"><a href="#RPC-在架构中的位置" class="headerlink" title="RPC 在架构中的位置"></a>RPC 在架构中的位置</h1><p><strong>RPC 框架能够帮助我们解决系统拆分后的通信问题，并且能让我们像调用本地一样去调用远程方法。</strong> 利用 RPC 我们不仅可以很方便地将应用架构从“单体”演进成“微服务化”，而且还能解决实际开发过程中的效率低下、系统耦合等问题，这样可以使得我们的系统架构整体清晰、健壮，应用可运维度增强。</p><p>RPC 不仅可以用来解决通信问题，它还被用在了很多其他场景，比如：发 MQ、分布式缓存、数据库等。下图是作者之前开发的一个应用架构图：</p><p><img src="/2025/04/08/RPC-%E4%BB%80%E4%B9%88%E6%98%AFRPC%EF%BC%9FRPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/f1c131789d1c5cfdecfa8aa51ef56a98.png"></p><p>从上图可以看到，用MQ来处理异步流程、Redis缓存热点数据、MySQL持久化数据，还有在系统中调用另外一个业务系统的接口，这些都是属于 RPC 调用，而 MQ、MySQL 持久化的数据也会存在于一个分布式文件系统中，他们之间的调用也是需要用 RPC 来完成数据交互的。</p>]]></content>
    
    
    <categories>
      
      <category>RPC实战与核心原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络通信</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射机制</title>
    <link href="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结Java中的反射机制</p>          </div><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><strong>作用：</strong><ul><li>通过Java语言中的反射机制，可以<strong>操作字节码文件</strong></li></ul></li><li><strong>应用：</strong><ul><li>编写能够<strong>动态</strong>操纵Java代码的程序</li><li>使用反射，Java可以支持用户界面生成器、对象关系映射器以及很多其他<u>需要动态查询类能力的开发工具</u>。主要作用在<strong>开发工具</strong>时</li></ul></li><li>在 <code>java.lang,reflect,*;</code> 包下</li><li>反射机制相关的重要的类：<ul><li><code>java.lang.Class</code>：整个字节码，代表一个类型（<em>整个类</em>）</li><li><code>java.lang.reflect.Method</code>：字节码中的方法字节码（类中的<em>方法</em>）</li><li><code>java.lang.reflect.Constructor</code>：字节码中的构造方法字节码（类中的<em>构造方法</em>）</li><li><code>java.lang.reflect.Field</code>：字节码中的属性字节码（类中的<em>成员变量（静态变量+实例变量）</em>）<br>  具体如下：</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chen.reflection;    <span class="hljs-comment">/**  </span><span class="hljs-comment"> * java.lang.Class</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> chen  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2025/4/5 19:18  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0  </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;      <span class="hljs-comment">// Field: 成员变量  </span>    <span class="hljs-type">int</span> no;        <span class="hljs-comment">// Constructor: 构造方法  </span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;&#125;      <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;        <span class="hljs-comment">// Method: 方法  </span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;          <span class="hljs-keyword">return</span> no;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;  &#125;</code></pre></div><p>要操作一个类的字节码，要先获取该类的字节码，即该类的 <code>Class</code>。也就是说，要操作 <code>Method</code>、<code>Constructor</code>、<code>Field</code>，需要先获取到 <code>Class</code></p><h1 id="获取Class的三种方式"><a href="#获取Class的三种方式" class="headerlink" title="获取Class的三种方式"></a>获取Class的三种方式</h1><h2 id="1、Class-forName-完整类名"><a href="#1、Class-forName-完整类名" class="headerlink" title="1、Class.forName(&quot;完整类名&quot;);"></a>1、<code>Class.forName(&quot;完整类名&quot;);</code></h2><p>要求：</p><ol><li>静态方法</li><li>方法的参数是一个字符串</li><li>字符串需要的是一个完整类名</li><li>完整类名必须带有包名</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-comment">// c1 代表 String.class 文件，或者说代表 String 类  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);              <span class="hljs-comment">// c2代表 Date 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.util.Date&quot;</span>);              <span class="hljs-comment">// c3 代表 Integer 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Integer&quot;</span>);              <span class="hljs-comment">// c4 代表 System 类型  </span>            <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.System&quot;</span>);          &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;              e.printStackTrace();          &#125;      &#125;  &#125;</code></pre></div><ul><li><code>Class.forName(&quot;完整类名&quot;);</code> - 该方法的执行，会导致<strong>类加载</strong>，类加载时，静态代码块执行：</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          Class.forName(<span class="hljs-string">&quot;com.chen.reflection.MyClass&quot;</span>);      &#125;  &#125;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;      <span class="hljs-keyword">static</span> &#123;          System.out.println(<span class="hljs-string">&quot;MyClass 的静态代码块&quot;</span>);      &#125;  &#125;</code></pre></div><ul><li>输出：<br><img src="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/1.png"></li></ul><h2 id="2、对象-getClass"><a href="#2、对象-getClass" class="headerlink" title="2、对象.getClass();"></a>2、<code>对象.getClass();</code></h2><p>Java中任何一个对象都有 <code>getClass()</code> 方法：（Object类中实现的方法）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;          <span class="hljs-keyword">try</span> &#123;              c1 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);          &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;              e.printStackTrace();          &#125;            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;          <span class="hljs-comment">// x 代表 String.class 字节码文件，或者说 代表 String 类型  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> s.getClass();          <span class="hljs-comment">// c1 和 x 中保存的内存地址是一样的</span>        System.out.println(c1 == x);   <span class="hljs-comment">// true</span>    &#125;  &#125;</code></pre></div><p>底层实现如下：<br><img src="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/2.png"></p><h2 id="3、任何类型-class"><a href="#3、任何类型-class" class="headerlink" title="3、任何类型.class;"></a>3、<code>任何类型.class;</code></h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> String.class;          System.out.println(c);    <span class="hljs-comment">// class java.lang.String  </span>    &#125;  &#125;</code></pre></div><h1 id="通过反射实例化对象"><a href="#通过反射实例化对象" class="headerlink" title="通过反射实例化对象"></a>通过反射实例化对象</h1><p><strong>反射机制的灵活性：</strong></p><ul><li>Java代码在不改变源代码的基础上，可以做到不同对象的实例化</li><li>符合开闭原则：对扩展开放，对修改关闭</li></ul><p>如果我们有一个 <code>properties</code> 文件：</p><div class="code-wrapper"><pre><code class="hljs text">className=java.util.Date</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-comment">// 这种方式，只能创建一个User对象，代码写死了  </span>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();            <span class="hljs-comment">/*  </span><span class="hljs-comment">        * 以下方式，创建的对象依赖我们的properties配置文件  </span><span class="hljs-comment">        * */</span>        <span class="hljs-comment">// 通过 IO 流读取 classinfo.properties 文件  </span>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;classinfo.properties&quot;</span>);          <span class="hljs-comment">// 创建属性类对象map  </span>        <span class="hljs-type">Properties</span> <span class="hljs-variable">pro</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();          <span class="hljs-comment">// 加载  </span>        pro.load(reader);          <span class="hljs-comment">// 关闭流  </span>        reader.close();            <span class="hljs-comment">// 通过key获取value  </span>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> pro.getProperty(<span class="hljs-string">&quot;className&quot;</span>);          System.out.println(className);            <span class="hljs-comment">// 通过反射机制实例化对象  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(className);          <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> c.newInstance();          System.out.println(o);      &#125;  &#125;</code></pre></div><h1 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-comment">// 获取整个类  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">userClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.entity.User&quot;</span>);          <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> userClass.newInstance();   <span class="hljs-comment">// obj就是User对象，底层调用该对象的无参构造方法  </span>          <span class="hljs-comment">// 获取no属性  </span>        Field noField=  userClass.getDeclaredField(<span class="hljs-string">&quot;no&quot;</span>);            <span class="hljs-comment">// 给obj对象的no属性赋值  </span>        noField.set(obj, <span class="hljs-number">111</span>);          <span class="hljs-comment">// 读取值  </span>        System.out.println(noField.get(obj));   <span class="hljs-comment">// 111  </span>    &#125;  &#125;</code></pre></div><ul><li>反射机制的<strong>缺点</strong>：<strong>打破封装，可以访问到private方法</strong></li></ul><h1 id="调用对象方法"><a href="#调用对象方法" class="headerlink" title="调用对象方法"></a><strong>调用对象方法</strong></h1><p>有个 <code>UserService</code> 类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.chen.reflection.service;    <span class="hljs-comment">/**  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> chen  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2025/4/7 19:50  </span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0  </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String name, String password)</span> &#123;          <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;admin&quot;</span>.equals(name) &amp;&amp; <span class="hljs-string">&quot;123&quot;</span>.equals(password)) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">()</span> &#123;          System.out.println(<span class="hljs-string">&quot;已退出&quot;</span>);      &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">userServiceClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.service.UserService&quot;</span>);          <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> userServiceClass.newInstance();          <span class="hljs-type">Method</span> <span class="hljs-variable">loginMethod</span> <span class="hljs-operator">=</span> userServiceClass.getDeclaredMethod(<span class="hljs-string">&quot;login&quot;</span>, String.class, String.class);          <span class="hljs-comment">// 返回值  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> loginMethod.invoke(obj, <span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);          System.out.println(returnValue);      &#125;  &#125;</code></pre></div><h1 id="调用构造方法实例化对象"><a href="#调用构造方法实例化对象" class="headerlink" title="调用构造方法实例化对象"></a>调用构造方法实例化对象</h1><p>现在有一个 <code>User</code> 类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;      <span class="hljs-comment">// Field  </span>    <span class="hljs-type">int</span> no;      String name;      <span class="hljs-type">int</span> age;      <span class="hljs-type">boolean</span> sex;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, <span class="hljs-type">int</span> age)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;          <span class="hljs-built_in">this</span>.age = age;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> no, String name, <span class="hljs-type">int</span> age, <span class="hljs-type">boolean</span> sex)</span> &#123;          <span class="hljs-built_in">this</span>.no = no;          <span class="hljs-built_in">this</span>.name = name;          <span class="hljs-built_in">this</span>.age = age;          <span class="hljs-built_in">this</span>.sex = sex;      &#125;  &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chen.reflection.entity.User&quot;</span>);          <span class="hljs-comment">// 调用无参构造方法  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> c.newInstance();          System.out.println(obj);            <span class="hljs-comment">// 调用有参构造方法  </span>        <span class="hljs-comment">// 1、获取到这个有参数的构造方法  </span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(<span class="hljs-type">int</span>.class, String.class);          <span class="hljs-comment">// 2、调用构造方法new对象  </span>        <span class="hljs-type">Object</span> <span class="hljs-variable">newObj</span> <span class="hljs-operator">=</span> con.newInstance(<span class="hljs-number">110</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);          System.out.println(newObj);            <span class="hljs-comment">// 获取无参构造方法  </span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">con2</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor();          <span class="hljs-type">Object</span> <span class="hljs-variable">newObj2</span> <span class="hljs-operator">=</span> con2.newInstance();          System.out.println(newObj2);      &#125;  &#125;</code></pre></div><h1 id="获取父类和父接口"><a href="#获取父类和父接口" class="headerlink" title="获取父类和父接口"></a>获取父类和父接口</h1><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;          <span class="hljs-type">Class</span> <span class="hljs-variable">stringClass</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);            <span class="hljs-comment">// 获取String的父类  </span>        <span class="hljs-type">Class</span> <span class="hljs-variable">superClass</span> <span class="hljs-operator">=</span> stringClass.getSuperclass();          System.out.println(superClass.getName());            System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);            <span class="hljs-comment">// 获取String类实现的所有接口  </span>        Class[] interfaces = stringClass.getInterfaces();          <span class="hljs-keyword">for</span> (Class in : interfaces) &#123;              System.out.println(in.getName());          &#125;      &#125;  &#125;</code></pre></div><p><img src="/2025/04/08/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/3.png"></p><h1 id="反射的弊端"><a href="#反射的弊端" class="headerlink" title="反射的弊端"></a>反射的弊端</h1><ol><li>反射很慢<ul><li>慢的原因：反射调用需要找到目标方法，而找目标方法是通过遍历当前类甚至是父类的方法来找，并且调用，这个时间复杂度<code>O(n)</code></li><li>如何解决：可以将目标方法缓存起来，下次直接调用而并非先找到目标方法再调用</li></ul></li><li>使用反射会有安全性的问题<ul><li>反射打破了封装，可以访问到private方法，可能有让黑客有窃取信息的漏洞</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL日志</title>
    <link href="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/"/>
    <url>/2025/04/07/MySQL%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>本文主要总结MySQL中的三大日志（redo log、undo log、binlog）</p>          </div><h1 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a>一、分类</h1><ol><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>归档日志（bin log）</li><li>错误日志（error log）</li><li>慢查询日志（slow query log）</li><li>一般查询日志（general log）</li><li>中继日志（relay log）</li></ol><h1 id="二、redo-log"><a href="#二、redo-log" class="headerlink" title="二、redo log"></a>二、redo log</h1><p>重做日志，<strong>InnoDB存储引擎独有</strong>的日志，主要作用：让MySQL拥有<strong>崩溃恢复</strong>的能力</p><ul><li>MySQL实例挂了或宕机了，重启后，InnoDB存储引擎会使用redo log恢复数据</li></ul><h2 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h2><ol><li>物理日志<ul><li>记录的是<strong>在某个数据页做了什么修改</strong></li></ul></li><li>保证数据的持久性<ul><li>redo log会在<strong>事务提交时</strong>将日志存储到磁盘 <code>Redo Log File</code> ，保证<strong>日志的持久性</strong></li><li>同时MySQL会将数据写入磁盘，保证<strong>数据的持久性</strong></li></ul></li></ol><h2 id="2、组成"><a href="#2、组成" class="headerlink" title="2、组成"></a>2、组成</h2><ol><li><p>Redo Log Buffer：内存中的重做日志<strong>缓存</strong></p></li><li><p>Redo Log File：重做日志<strong>文件</strong></p></li></ol><p>MySQL中数据是以<strong>页</strong>为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到Buffer Pool中。后续的查询都是先从Buffer Pool中找，没有命中再去硬盘加载，<strong>减少硬盘IO开销，提升性能。</strong></p><p>更新表数据的时候，也是如此，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新。然后会把在某个数据页上做了什么修改记录到重做日志缓存（Redo Log Buffer）里，接着刷盘到Redo Log文件里。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面。</p><ul><li>流程如下：</li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407162420090.png"></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><strong>固定大小</strong>，循环写入</p><ul><li>配置为一组4个文件，每个文件1GB大小</li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164547681.png"></p><ul><li><strong>注意这里有一个<code>check point</code>，如果发生异常，redolog就是根据checkpoint来感知到，数据要恢复到哪里的</strong></li></ul><h3 id="WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘"><a href="#WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘" class="headerlink" title="WAL(Write-Ahead Logging)技术：先写日志、再写磁盘"></a>WAL(Write-Ahead Logging)技术：先写日志、再写磁盘</h3><div class="note note-danger">            <p>为什么要在写磁盘前先写日志？直接写磁盘不可以吗？</p>          </div><ul><li><p>性能问题：</p><ol><li><strong>redolog结构简单：</strong><ul><li>InnoDB在磁盘中存储的基本单元是页，可能本次修改只变更一页中几个字节，但是需要刷新整页的数据，<strong>浪费资源</strong></li><li>redolog记录的是物理层面上的数据修改，因此redolog也叫物理日志。这些修改记录包含了数据页的物理地址（Page Number）和修改的具体内容（在某个数据页做了什么修改）</li><li>正是因为redolog中记录的数据结构简单，只记录一些物理地址以及变更状态等信息，因此数据先写入redolog要比直接写入到表快多了</li><li>Redo Log作为“临时存储的数据区域”，当Redo Buffer中的数据已经到达一定大小后，Redo Buffer也会将这部分数据写入到Redo Log中，此时数据还未提交，但是已经写入到磁盘中了。</li></ul></li></ol><p>  <img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250408183748948.png" alt="InnoDB数据页和RedoLog日志格式"></p><ol start="2"><li><strong>顺序IO性能远高于随机IO：</strong><ul><li>数据在MySQL中存储是以页为单位的，一个事务可能修改了多页中的数据，页之间又是不连续的，如果直接写入到磁盘中对应的页中，就会产生<strong>随机IO，性能更差</strong></li><li>redolog是通过往redolog日志中追加数据的方式，属于<strong>顺序IO</strong>，效率高。这样可能会影响Redo Log恢复数据时的性能，但可以保证在提交时期能够快速写入Redo Log日志记录本次事务的更改。</li></ul></li></ol></li></ul><h2 id="3、刷盘时机"><a href="#3、刷盘时机" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>InnoDB存储引擎为Redo Log的刷盘策略提供了 <code>innodb-f1ush_log-at_-trX-commit</code> 参数，它支持三种策略：</p><h3 id="（1）0-延时写"><a href="#（1）0-延时写" class="headerlink" title="（1）0 延时写"></a>（1）0 延时写</h3><p>每次事务提交时都只是把redo log留在redo log buffer中，开启一个后台线程，<strong>每1s刷新一次到磁盘中</strong>：</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407163806765.png"></p><ul><li>风险：如果数据库宕机了，可能会丢失1秒内的数据</li></ul><h3 id="（2）1-实时写、实时刷"><a href="#（2）1-实时写、实时刷" class="headerlink" title="（2）1 实时写、实时刷"></a>（2）1 实时写、实时刷</h3><p>每次<strong>事务提交时</strong>都将redo log直接持久化到磁盘，<strong>真正保证数据的持久性</strong>（<strong>默认值</strong>)</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164032208.png"></p><ul><li>只要事务提交成功，redo log记录就一定在硬盘里，<strong>不会有任何数据丢失</strong></li><li>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</li></ul><h3 id="（3）2-实时写、延时刷"><a href="#（3）2-实时写、延时刷" class="headerlink" title="（3）2 实时写、延时刷"></a>（3）2 实时写、延时刷</h3><p>每次事务提交时都只是把 redo log 写到 page cache，每秒刷一次到磁盘（速度快，但是会丢1s的数据，甚至更多，1s并不严格）</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407164428343.png"></p><h1 id="三、undo-log"><a href="#三、undo-log" class="headerlink" title="三、undo log"></a>三、undo log</h1><p><strong>回滚日志</strong>，redo log一旦提交意味着持久化了，但有时候需要对其进行回滚操作，那就需要undo log</p><h2 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h2><ul><li>逻辑日志，可以理解为存储的是sql：<ul><li>在事务中使用的每一条 INSERT 都对应了一条 DELETE</li><li>每一条 UPDATE 都对应一条相反的 UPDATE 语句</li></ul></li></ul><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407165157198.png"></p><ul><li>保证事务的<strong>一致性</strong></li></ul><p>详见：MVCC机制</p><h1 id="四、binlog"><a href="#四、binlog" class="headerlink" title="四、binlog"></a>四、binlog</h1><p>归档日志，MySQL的<strong>Server层</strong>实现的日志，所有引擎都可以使用，主要作用：备份恢复、灾难恢复、主从复制</p><h2 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h2><ul><li>逻辑日志，记录语句的原始逻辑</li><li><strong>追加</strong>写入，写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</li></ul><div class="note note-danger">            <p>既然有了redolog，为什么还要有binlog？</p>          </div><p>给出两个日志的对比：</p><table><thead><tr><th>redo log</th><th>binlog</th></tr></thead><tbody><tr><td>InnoDB 引擎特有的</td><td>MySQL的<strong>Server层</strong>实现的，<br /><strong>所有引擎</strong>都可以使用</td></tr><tr><td><strong>物理</strong>日志，<br />记录“在某个数据页上做了什么修改”</td><td><strong>逻辑</strong>日志，<br />记录这个语句的原始逻辑（“给ID&#x3D;2这一行的c字段加1”）</td></tr><tr><td><strong>循环</strong>写，空间固定会用完</td><td><strong>追加</strong>写入，<br />写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</td></tr></tbody></table><ol><li><p><strong>历史原因：</strong></p><ul><li><p>最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="保证即使数据库发生异常重启，之前提交的记录都不会丢失的能力，我们称为**crash-safe**">[1]</span></a></sup> 的能力，binlog 日志只能用于<strong>归档</strong></p></li><li><p>InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力</p></li></ul></li><li><p><strong>用途方面：</strong></p><ul><li>正是因为binlog日志<strong>不会覆盖以前的日志</strong>的特点，如果不小心把<strong>整个数据库的数据</strong>删除了，只能使用binlog文件进行恢复，因为redolog日志的空间是固定的，会覆盖掉之前的日志。<ul><li>即：<strong>binlog用于灾难恢复的场景，而redolog只能恢复较近的数据。</strong></li></ul></li></ul></li></ol><h2 id="2、组成-1"><a href="#2、组成-1" class="headerlink" title="2、组成"></a>2、组成</h2><p>binlog有三种格式</p><h3 id="（1）Statement"><a href="#（1）Statement" class="headerlink" title="（1）Statement"></a>（1）Statement</h3><ul><li>记录<strong>SQL语句的原文</strong></li></ul><p>会出现的问题：对于一些时间函数（比如<code>now()</code>）会导致主从同步的数据前后不一致</p><h3 id="（2）Row"><a href="#（2）Row" class="headerlink" title="（2）Row"></a>（2）Row</h3><ul><li>记录<strong>数据的具体变化</strong><ul><li>insert：新插入的行的所有字段列的值</li><li>update：行更新前后的所有字段列的值</li><li>delete：行删除前的所有字段列的值</li></ul></li></ul><p>数据更安全，但同时，文件也更大</p><h3 id="（3）Mixed"><a href="#（3）Mixed" class="headerlink" title="（3）Mixed"></a>（3）Mixed</h3><p>由MySQL自主选择以上的两种格式</p><p>默认使用Statement，遇到可能导致主从不一致的SQL语句时，改用Row</p><h2 id="3、刷盘时机-1"><a href="#3、刷盘时机-1" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>和redolog一样，都是WAL日志，刷盘时机由 <code>sync_binlog</code> 配置参数指定</p><ul><li><p>0（延迟写）：每次提交事务都不会刷盘，由系统自己决定什么时候刷盘，可能会丢失数据。</p></li><li><p>1（实时写）：每次提交事务，都会刷盘，性能较差。</p></li><li><p>N（延迟写）：提交N个事务后，才会刷盘。</p></li></ul><p>接下来可以完善一下上面的redolog提交事务的图：</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407183824785.png"></p><h3 id="关于两阶段提交"><a href="#关于两阶段提交" class="headerlink" title="关于两阶段提交"></a>关于两阶段提交</h3><div class="note note-danger">            <p>为什么需要两阶段提交？</p>          </div><ul><li><p>为了解决两个日志之间<strong>逻辑一致</strong>的问题。</p><ul><li>如果redolog写完之后，binlog写入时发生了异常，导致binlog和redolog之间的逻辑不一致</li><li>如果采用两阶段提交，就可以感知到写入binlog时发生了异常，后续再进行回滚或是别的补偿操作即可<ul><li>写入binlog时如果发生了异常，MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应bin log日志，就会回滚该事务</li></ul></li></ul></li><li><p>如果是redolog commit阶段发生了异常，则不会回滚事务，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的bin log日志，所以MySQL认为是完整的，就会提交事务恢复数据</p></li></ul><h3 id="系统崩溃后重启如何刷新数据？"><a href="#系统崩溃后重启如何刷新数据？" class="headerlink" title="系统崩溃后重启如何刷新数据？"></a>系统崩溃后重启如何刷新数据？</h3><ul><li>写入undo log之前崩溃：这时undo log和bin log中都没有数据，此时满足数据一致性不需要进行操作</li><li>写入bin log之前崩溃：此时根据undo log中的事务id去bin log中查找是没有数据的，因此会回滚</li><li>写入bin log之后崩溃：无论redo log有没有修改为commit状态，都会把数据更新到磁盘</li></ul><p>这种机制确保了在MySQL主从复制架构中，即使在某个阶段MySQL宕机，也可以在恢复时根据redo log和binlog的状态来决定是否提交或回滚事务，从而保证了主从机的数据一致性。</p><h2 id="4、主从复制"><a href="#4、主从复制" class="headerlink" title="4、主从复制"></a>4、主从复制</h2><p>MySQL的主从复制依赖于bin log，也就是<strong>记录MySQL上的所有变化</strong>并<strong>以二进制形式保存在磁盘</strong>上。</p><p>复制过程：将binlog中的数据从主库传输到从库（异步操作）</p><p><img src="/2025/04/07/MySQL%E6%97%A5%E5%BF%97/image-20250407190151841.png"></p><p>MySQL集群的主从复制过程梳理成3个阶段：</p><ol><li>写入Bin log：主库写bin log日志，提交事务，并更新本地存储数据</li><li>同步Bin log：把bin log复制到所有从库上，每个从库把bin log写到暂存日志中</li><li>回放Bin log：回放bin log，并更新存储引擎中的数据</li></ol><blockquote><p>关于MySQL的集群，埋个坑。。。</p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>保证即使数据库发生异常重启，之前提交的记录都不会丢失的能力，我们称为<strong>crash-safe</strong><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Zset</title>
    <link href="/2025/04/07/Redis-Zset/"/>
    <url>/2025/04/07/Redis-Zset/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍 Redis Zset 的底层数据结构实现即原理。</p></blockquote><p>zset底层在数据少的时候是压缩列表，数据量多了会进化成跳表。</p><h1 id="什么时候用压缩列表，什么时候用跳表？"><a href="#什么时候用压缩列表，什么时候用跳表？" class="headerlink" title="什么时候用压缩列表，什么时候用跳表？"></a>什么时候用压缩列表，什么时候用跳表？</h1><p>压缩列表使用要求：</p><ul><li>有序集合保存的元素<strong>数量小于128个</strong></li><li>有序集合保存的所有元素<strong>长度小于64字节</strong><br>  如果不满足以上两个条件之一，则进化成跳表</li></ul><h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表底层就是<strong>有序数组 + 标识符</strong>，标识符包括：列表长度、尾部偏移量、列表元素个数、列表结束标识符：</p><ul><li><strong>列表长度</strong>：保存整个压缩列表占用的内存字节数</li><li><strong>尾部偏移量</strong>：保存压缩列表起始地址到最后一个节点的字节数，可以快速定位到最后一个节点</li><li><strong>列表元素个数</strong>：保存压缩列表的节点个数</li><li><strong>列表结束标识符</strong>：特殊值0xFF（十进制为255），表示压缩列表的结束</li></ul><p>压缩列表结构：<br><img src="/2025/04/07/Redis-Zset/1.png"></p><ul><li>如果查找定位第一个元素和最后一个元素：时间复杂度为 <code>O(1)</code> - 通过表头三个字段直接定位</li><li>查找其他元素只能逐个查找：时间复杂度为 <code>O(n)</code></li></ul><h1 id="为什么用跳表？"><a href="#为什么用跳表？" class="headerlink" title="为什么用跳表？"></a>为什么用跳表？</h1><p>跳表是在<strong>有序链表</strong>的基础上进化而来的，它结合了：</p><ol><li><p><strong>链表</strong>在内存空间中不需要一块连续的区域</p></li><li><p><strong>有序数组</strong>的高效的查找算法：二分查找</p></li></ol><p>  两个优点。具体来说，<em>跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现了数据的快速定位。</em> 如下：<br>  <img src="/2025/04/07/Redis-Zset/NeatReader-1743990195139.png" alt="NeatReader-1743990195139"></p><ul><li>跳表在链表的基础上增加了多级索引以提升查找的效率，其实是一个<strong>空间换时间</strong>的方案，必然会带来一个问题：索引是占内存的</li><li>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略</li></ul><h1 id="跳表的具体实现"><a href="#跳表的具体实现" class="headerlink" title="跳表的具体实现"></a>跳表的具体实现</h1><h2 id="1、普通的有序单向链表"><a href="#1、普通的有序单向链表" class="headerlink" title="1、普通的有序单向链表"></a>1、普通的有序单向链表</h2><p><img src="/2025/04/07/Redis-Zset/20250407094915.png"></p><p>如果我们需要查找节点33，需要从头节点开始一个个遍历，遍历6次，时间复杂度为 <code>O(n)</code></p><h2 id="2、优化"><a href="#2、优化" class="headerlink" title="2、优化"></a>2、优化</h2><p>我们在以上的有序单向链表的上一层，再添加一个一级索引：<br><img src="/2025/04/07/Redis-Zset/20250407095240.png" alt="Pasted image 20250407095240"></p><ul><li>查找节点33，遍历顺序为：<code>1 -&gt; 11 -&gt; 27 -&gt; 33</code>，一共遍历4次</li></ul><p>如果再向上添加一级索引：<br><img src="/2025/04/07/Redis-Zset/20250407095612.png"></p><ul><li>查找节点33，遍历顺序为：<code>1 -&gt; 27 -&gt; 33</code>，只需要遍历3次</li></ul><h1 id="索引建立时机"><a href="#索引建立时机" class="headerlink" title="索引建立时机"></a>索引建立时机</h1><p>前面提到，跳表的实现还是<strong>基于有序数组的二分查找</strong>来实现的，具体如下：<br>我们在新加一个节点的时候，可以考虑一下，现在最多有几层索引，如果现在一层都没有，上来就建了8层，就很没有必要，索引新加一个节点最好最多再往上建立一层索引，那么具体多少层，可以这么想，在第一层建立的概率是1&#x2F;2，第二层建立的概率是1&#x2F;4，第三层建立的概率是1&#x2F;8……</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (level &lt; maxLevel &amp;&amp; Math.random() &gt; <span class="hljs-number">0.5</span>) &#123;        level++;    &#125;    <span class="hljs-keyword">return</span> level;&#125;</code></pre></div><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;      <span class="hljs-comment">// 随机因子，这里设置成0.5</span>    <span class="hljs-type">double</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5d</span>;        <span class="hljs-comment">// 最大层级  </span>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;        <span class="hljs-comment">// 当前最大层级  </span>    <span class="hljs-type">int</span> <span class="hljs-variable">currentMaxLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(maxLevel, -<span class="hljs-number">1</span>);        <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;          <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;          <span class="hljs-comment">// 从最大层开始查找，找到前一节点，通过--i，移动到下层再开始查找  </span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;              <span class="hljs-keyword">while</span> (p.nextNodes[i] != <span class="hljs-literal">null</span> &amp;&amp; p.nextNodes[i].value &lt; value) &#123;                  <span class="hljs-comment">// 找到前一节点  </span>                p = p.nextNodes[i];              &#125;          &#125;            <span class="hljs-keyword">if</span> (p.nextNodes[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span> &amp;&amp; p.nextNodes[<span class="hljs-number">0</span>].value == value) &#123;              <span class="hljs-keyword">return</span> p.nextNodes[<span class="hljs-number">0</span>];          &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;          <span class="hljs-comment">// level代表这个节点存在于几层链表中  </span>        <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> randomLevel();          <span class="hljs-keyword">if</span> (level &gt; currentMaxLevel) &#123;              level = ++currentMaxLevel;          &#125;          <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(level, value);          <span class="hljs-type">Node</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> head;          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> currentMaxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;              <span class="hljs-comment">// 如果当前节点当前层级的下一个节点不为空，且比下一个节点的值小  往下走  </span>            <span class="hljs-keyword">while</span> (point.nextNodes[i] != <span class="hljs-literal">null</span> &amp;&amp; point.nextNodes[i].value &lt; value) &#123;                  point = point.nextNodes[i];              &#125;              <span class="hljs-comment">// 节点层级比当前层级大，在该层级插入该节点   之后继续遍历  </span>            <span class="hljs-keyword">if</span> (level &gt; i) &#123;                  <span class="hljs-type">Node</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> point.nextNodes[i];                  point.nextNodes[i] = newNode;                  newNode.nextNodes[i] = temp;              &#125;          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;        <span class="hljs-comment">// 随机层级，如果生成的概率&gt;0.5，就level++  </span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">randomLevel</span><span class="hljs-params">()</span> &#123;          <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;          <span class="hljs-keyword">while</span> (level &lt; maxLevel &amp;&amp; Math.random() &gt; factor) &#123;              level++;          &#125;          <span class="hljs-keyword">return</span> level;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAll</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;          <span class="hljs-keyword">if</span> (level &gt; currentMaxLevel) &#123;              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;还没有到这个层数&quot;</span>);          &#125;          <span class="hljs-type">Node</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> head;          <span class="hljs-keyword">while</span> (point.nextNodes[level - <span class="hljs-number">1</span>] != <span class="hljs-literal">null</span>) &#123;              System.out.print(point.nextNodes[level - <span class="hljs-number">1</span>] + <span class="hljs-string">&quot; &quot;</span>);              point = point.nextNodes[level - <span class="hljs-number">1</span>];          &#125;          System.out.println();      &#125;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;          <span class="hljs-comment">// 节点值  </span>        <span class="hljs-type">int</span> value;            <span class="hljs-comment">/**  </span><span class="hljs-comment">         * 这个节点在某一层的下一个节点的集合，比如nextNodes[2]就是node在第二层的下一个节点  </span><span class="hljs-comment">         */</span>          Node[] nextNodes;            <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">int</span> value)</span> &#123;              nextNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[level];              <span class="hljs-built_in">this</span>.value = value;          &#125;            <span class="hljs-meta">@Override</span>          <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;              <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Node&#123;&quot;</span> +                      <span class="hljs-string">&quot;value=&quot;</span> + value +                      <span class="hljs-string">&#x27;&#125;&#x27;</span>;          &#125;      &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;          <span class="hljs-type">SkipList</span> <span class="hljs-variable">skipList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipList</span>();          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;              skipList.insert(i);          &#125;          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> skipList.currentMaxLevel; i &gt; <span class="hljs-number">0</span>; i--) &#123;              skipList.printAll(i);          &#125;      &#125;  &#125;</code></pre></div><h1 id="为什么不使用红黑树？"><a href="#为什么不使用红黑树？" class="headerlink" title="为什么不使用红黑树？"></a>为什么不使用红黑树？</h1><ol><li>虽然跳表消耗较多的内存，但是我们内部优化过跳表，可以接受。</li><li>跳表的实现很简单，至少比红黑树简单的多。</li><li>多范围查询的支持，跳表完胜红黑树。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
