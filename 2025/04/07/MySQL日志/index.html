<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        chenchen
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            MySQL日志
        </p>
        <hr>
    </div>
    <div class="post-content">
        <blockquote>
<p>本文主要总结MySQL中的三大日志（redo log、undo log、binlog）</p>
</blockquote>
<h1 id="一、分类"><a href="#一、分类" class="headerlink" title="一、分类"></a>一、分类</h1><ol>
<li>重做日志（redo log）</li>
<li>回滚日志（undo log）</li>
<li>归档日志（bin log）</li>
<li>错误日志（error log）</li>
<li>慢查询日志（slow query log）</li>
<li>一般查询日志（general log）</li>
<li>中继日志（relay log）</li>
</ol>
<h1 id="二、redo-log"><a href="#二、redo-log" class="headerlink" title="二、redo log"></a>二、redo log</h1><p>重做日志，<strong>InnoDB存储引擎独有</strong>的日志，主要作用：让MySQL拥有<strong>崩溃恢复</strong>的能力</p>
<ul>
<li>MySQL实例挂了或宕机了，重启后，InnoDB存储引擎会使用redo log恢复数据</li>
</ul>
<h2 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h2><ol>
<li>物理日志<ul>
<li>记录的是<strong>在某个数据页做了什么修改</strong></li>
</ul>
</li>
<li>保证数据的持久性<ul>
<li>redo log会在<strong>事务提交时</strong>将日志存储到磁盘 <code>Redo Log File</code> ，保证<strong>日志的持久性</strong></li>
<li>同时MySQL会将数据写入磁盘，保证<strong>数据的持久性</strong></li>
</ul>
</li>
</ol>
<h2 id="2、组成"><a href="#2、组成" class="headerlink" title="2、组成"></a>2、组成</h2><ol>
<li><p>Redo Log Buffer：内存中的重做日志<strong>缓存</strong></p>
</li>
<li><p>Redo Log File：重做日志<strong>文件</strong></p>
</li>
</ol>
<p>MySQL中数据是以<strong>页</strong>为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到Buffer Pool中。后续的查询都是先从Buffer Pool中找，没有命中再去硬盘加载，<strong>减少硬盘IO开销，提升性能。</strong></p>
<p>更新表数据的时候，也是如此，发现Buffer Pool里存在要更新的数据，就直接在Buffer Pool里更新。然后会把在某个数据页上做了什么修改记录到重做日志缓存（Redo Log Buffer）里，接着刷盘到Redo Log文件里。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面。</p>
<ul>
<li>流程如下：</li>
</ul>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407162420090.png" alt="image-20250407162420090"></p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><strong>固定大小</strong>，循环写入</p>
<ul>
<li>配置为一组4个文件，每个文件1GB大小</li>
</ul>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407164547681.png" alt="image-20250407164547681"></p>
<h3 id="WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘"><a href="#WAL-Write-Ahead-Logging-技术：先写日志、再写磁盘" class="headerlink" title="WAL(Write-Ahead Logging)技术：先写日志、再写磁盘"></a>WAL(Write-Ahead Logging)技术：先写日志、再写磁盘</h3><p>直接写磁盘不可以吗？</p>
<ul>
<li>性能问题：<ol>
<li>InnoDB在磁盘中存储的基本单元是页，可能本次修改只变更一页中几个字节，但是需要刷新整页的数据，<strong>浪费资源</strong>。</li>
<li>一个事务可能修改了多页中的数据，页之间又是不连续的，就会产生<strong>随机IO，性能更差</strong>。</li>
</ol>
</li>
</ul>
<h2 id="3、刷盘时机"><a href="#3、刷盘时机" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>InnoDB存储引擎为Redo Log的刷盘策略提供了 <code>innodb-f1ush_log-at_-trX-commit</code> 参数，它支持三种策略：</p>
<h3 id="（1）0-延时写"><a href="#（1）0-延时写" class="headerlink" title="（1）0 延时写"></a>（1）0 延时写</h3><p>每次事务提交时都只是把redo log留在redo log buffer中，开启一个后台线程，<strong>每1s刷新一次到磁盘中</strong>：</p>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407163806765.png" alt="image-20250407163806765"></p>
<ul>
<li>风险：如果数据库宕机了，可能会丢失1秒内的数据</li>
</ul>
<h3 id="（2）1-实时写、实时刷"><a href="#（2）1-实时写、实时刷" class="headerlink" title="（2）1 实时写、实时刷"></a>（2）1 实时写、实时刷</h3><p>每次<strong>事务提交时</strong>都将redo log直接持久化到磁盘，<strong>真正保证数据的持久性</strong>（<strong>默认值</strong>)</p>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407164032208.png" alt="image-20250407164032208"></p>
<ul>
<li>只要事务提交成功，redo log记录就一定在硬盘里，<strong>不会有任何数据丢失</strong></li>
<li>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</li>
</ul>
<h3 id="（3）2-实时写、延时刷"><a href="#（3）2-实时写、延时刷" class="headerlink" title="（3）2 实时写、延时刷"></a>（3）2 实时写、延时刷</h3><p>每次事务提交时都只是把 redo log 写到 page cache，每秒刷一次到磁盘（速度快，但是会丢1s的数据，甚至更多，1s并不严格）</p>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407164428343.png" alt="image-20250407164428343"></p>
<h1 id="三、undo-log"><a href="#三、undo-log" class="headerlink" title="三、undo log"></a>三、undo log</h1><p><strong>回滚日志</strong>，redo log一旦提交意味着持久化了，但有时候需要对其进行回滚操作，那就需要undo log</p>
<h2 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h2><ul>
<li>逻辑日志，可以理解为存储的是sql：<ul>
<li>在事务中使用的每一条 INSERT 都对应了一条 DELETE</li>
<li>每一条 UPDATE 都对应一条相反的 UPDATE 语句</li>
</ul>
</li>
</ul>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407165157198.png" alt="image-20250407165157198"></p>
<ul>
<li>保证事务的<strong>一致性</strong></li>
</ul>
<p>详见：MVCC机制</p>
<h1 id="四、binlog"><a href="#四、binlog" class="headerlink" title="四、binlog"></a>四、binlog</h1><p>归档日志，MySQL的<strong>Server层</strong>实现的日志，所有引擎都可以使用，主要作用：备份恢复、灾难恢复、主从复制</p>
<h2 id="1、特点-2"><a href="#1、特点-2" class="headerlink" title="1、特点"></a>1、特点</h2><ul>
<li>逻辑日志，记录语句的原始逻辑</li>
<li><strong>追加</strong>写入，写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</li>
</ul>
<blockquote>
<p>既然有了redolog，为什么还要有binlog？</p>
</blockquote>
<p>给出两个日志的对比：</p>
<table>
<thead>
<tr>
<th>redo log</th>
<th>binlog</th>
</tr>
</thead>
<tbody><tr>
<td>InnoDB 引擎特有的</td>
<td>MySQL的<strong>Server层</strong>实现的，<br /><strong>所有引擎</strong>都可以使用</td>
</tr>
<tr>
<td><strong>物理</strong>日志，<br />记录“在某个数据页上做了什么修改”</td>
<td><strong>逻辑</strong>日志，<br />记录这个语句的原始逻辑（“给ID&#x3D;2这一行的c字段加1”）</td>
</tr>
<tr>
<td><strong>循环</strong>写，空间固定会用完</td>
<td><strong>追加</strong>写入，<br />写到一定大小后会切换到下一个，<strong>不会覆盖</strong>以前的日志</td>
</tr>
</tbody></table>
<ul>
<li>正是因为binlog日志<strong>不会覆盖以前的日志</strong>的特点，如果不小心把整个数据库的数据删除了，只能使用binlog文件进行恢复，因为redolog日志的空间是固定的，会覆盖掉之前的日志。<ul>
<li>即：<strong>binlog用于灾难恢复的场景，而redolog只能恢复较近的数据。</strong></li>
</ul>
</li>
</ul>
<h2 id="2、组成-1"><a href="#2、组成-1" class="headerlink" title="2、组成"></a>2、组成</h2><p>binlog有三种格式</p>
<h3 id="（1）Statement"><a href="#（1）Statement" class="headerlink" title="（1）Statement"></a>（1）Statement</h3><ul>
<li>记录<strong>SQL语句的原文</strong></li>
</ul>
<p>会出现的问题：对于一些时间函数（比如<code>now()</code>）会导致主从同步的数据前后不一致</p>
<h3 id="（2）Row"><a href="#（2）Row" class="headerlink" title="（2）Row"></a>（2）Row</h3><ul>
<li>记录<strong>数据的具体变化</strong><ul>
<li>insert：新插入的行的所有字段列的值</li>
<li>update：行更新前后的所有字段列的值</li>
<li>delete：行删除前的所有字段列的值</li>
</ul>
</li>
</ul>
<p>数据更安全，但同时，文件也更大</p>
<h3 id="（3）Mixed"><a href="#（3）Mixed" class="headerlink" title="（3）Mixed"></a>（3）Mixed</h3><p>由MySQL自主选择以上的两种格式</p>
<p>默认使用Statement，遇到可能导致主从不一致的SQL语句时，改用Row</p>
<h2 id="3、刷盘时机-1"><a href="#3、刷盘时机-1" class="headerlink" title="3、刷盘时机"></a>3、刷盘时机</h2><p>和redolog一样，都是WAL日志，刷盘时机由 <code>sync_binlog</code> 配置参数指定</p>
<ul>
<li><p>0（延迟写）：每次提交事务都不会刷盘，由系统自己决定什么时候刷盘，可能会丢失数据。</p>
</li>
<li><p>1（实时写）：每次提交事务，都会刷盘，性能较差。</p>
</li>
<li><p>N（延迟写）：提交N个事务后，才会刷盘。</p>
</li>
</ul>
<p>接下来可以完善一下上面的redolog提交事务的图：</p>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407183824785.png" alt="image-20250407183824785"></p>
<h3 id="关于两阶段提交"><a href="#关于两阶段提交" class="headerlink" title="关于两阶段提交"></a>关于两阶段提交</h3><blockquote>
<p>为什么需要两阶段提交？</p>
</blockquote>
<ul>
<li><p>为了解决两个日志之间<strong>逻辑一致</strong>的问题。</p>
<ul>
<li><p>如果redolog写完之后，binlog写入时发生了异常，导致binlog和redolog之间的逻辑不一致</p>
</li>
<li><p>如果采用两阶段提交，就可以感知到binlog发生了异常，后续再进行回滚或是别的补偿操作即可</p>
<ul>
<li>binlog如果发生了异常，MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应bin log日志，就会回滚该事务</li>
</ul>
</li>
<li><p>如果是redolog commit阶段发生了异常，则不会回滚事务，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的bin log日志，所以MySQL认为是完整的，就会提交事务恢复数据</p>
</li>
</ul>
</li>
</ul>
<h2 id="4、主从复制"><a href="#4、主从复制" class="headerlink" title="4、主从复制"></a>4、主从复制</h2><p>MySQL的主从复制依赖于bin log，也就是<strong>记录MySQL上的所有变化</strong>并<strong>以二进制形式保存在磁盘</strong>上。</p>
<p>复制过程：将binlog中的数据从主库传输到从库（异步操作）</p>
<p><img src="/MySQL%E6%97%A5%E5%BF%97/image-20250407190151841.png" alt="image-20250407190151841"></p>
<p>MySQL集群的主从复制过程梳理成3个阶段：</p>
<ol>
<li>写入Bin log：主库写bin log日志，提交事务，并更新本地存储数据</li>
<li>同步Bin log：把bin log复制到所有从库上，每个从库把bin log写到暂存日志中</li>
<li>回放Bin log：回放bin log，并更新存储引擎中的数据</li>
</ol>
<blockquote>
<p>关于MySQL的集群，埋个坑。。。</p>
</blockquote>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>